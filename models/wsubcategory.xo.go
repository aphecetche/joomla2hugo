// Package toto contains the types for schema 'jlabo'.
package toto

// Code generated by xo. DO NOT EDIT.

import (
	"errors"
	"time"
)

// WsubCategory represents a row from 'jlabo.wsub_categories'.
type WsubCategory struct {
	ID             int       `json:"id"`               // id
	AssetID        uint      `json:"asset_id"`         // asset_id
	ParentID       uint      `json:"parent_id"`        // parent_id
	Lft            int       `json:"lft"`              // lft
	Rgt            int       `json:"rgt"`              // rgt
	Level          uint      `json:"level"`            // level
	Path           string    `json:"path"`             // path
	Extension      string    `json:"extension"`        // extension
	Title          string    `json:"title"`            // title
	Alias          string    `json:"alias"`            // alias
	Note           string    `json:"note"`             // note
	Description    string    `json:"description"`      // description
	Published      bool      `json:"published"`        // published
	CheckedOut     uint      `json:"checked_out"`      // checked_out
	CheckedOutTime time.Time `json:"checked_out_time"` // checked_out_time
	Access         uint      `json:"access"`           // access
	Params         string    `json:"params"`           // params
	Metadesc       string    `json:"metadesc"`         // metadesc
	Metakey        string    `json:"metakey"`          // metakey
	Metadata       string    `json:"metadata"`         // metadata
	CreatedUserID  uint      `json:"created_user_id"`  // created_user_id
	CreatedTime    time.Time `json:"created_time"`     // created_time
	ModifiedUserID uint      `json:"modified_user_id"` // modified_user_id
	ModifiedTime   time.Time `json:"modified_time"`    // modified_time
	Hits           uint      `json:"hits"`             // hits
	Language       string    `json:"language"`         // language
	Version        uint      `json:"version"`          // version

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the WsubCategory exists in the database.
func (wc *WsubCategory) Exists() bool {
	return wc._exists
}

// Deleted provides information if the WsubCategory has been deleted from the database.
func (wc *WsubCategory) Deleted() bool {
	return wc._deleted
}

// Insert inserts the WsubCategory to the database.
func (wc *WsubCategory) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if wc._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO jlabo.wsub_categories (` +
		`asset_id, parent_id, lft, rgt, level, path, extension, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, modified_user_id, modified_time, hits, language, version` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, wc.AssetID, wc.ParentID, wc.Lft, wc.Rgt, wc.Level, wc.Path, wc.Extension, wc.Title, wc.Alias, wc.Note, wc.Description, wc.Published, wc.CheckedOut, wc.CheckedOutTime, wc.Access, wc.Params, wc.Metadesc, wc.Metakey, wc.Metadata, wc.CreatedUserID, wc.CreatedTime, wc.ModifiedUserID, wc.ModifiedTime, wc.Hits, wc.Language, wc.Version)
	res, err := db.Exec(sqlstr, wc.AssetID, wc.ParentID, wc.Lft, wc.Rgt, wc.Level, wc.Path, wc.Extension, wc.Title, wc.Alias, wc.Note, wc.Description, wc.Published, wc.CheckedOut, wc.CheckedOutTime, wc.Access, wc.Params, wc.Metadesc, wc.Metakey, wc.Metadata, wc.CreatedUserID, wc.CreatedTime, wc.ModifiedUserID, wc.ModifiedTime, wc.Hits, wc.Language, wc.Version)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	wc.ID = int(id)
	wc._exists = true

	return nil
}

// Update updates the WsubCategory in the database.
func (wc *WsubCategory) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wc._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if wc._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE jlabo.wsub_categories SET ` +
		`asset_id = ?, parent_id = ?, lft = ?, rgt = ?, level = ?, path = ?, extension = ?, title = ?, alias = ?, note = ?, description = ?, published = ?, checked_out = ?, checked_out_time = ?, access = ?, params = ?, metadesc = ?, metakey = ?, metadata = ?, created_user_id = ?, created_time = ?, modified_user_id = ?, modified_time = ?, hits = ?, language = ?, version = ?` +
		` WHERE id = ?`

	// run query
	XOLog(sqlstr, wc.AssetID, wc.ParentID, wc.Lft, wc.Rgt, wc.Level, wc.Path, wc.Extension, wc.Title, wc.Alias, wc.Note, wc.Description, wc.Published, wc.CheckedOut, wc.CheckedOutTime, wc.Access, wc.Params, wc.Metadesc, wc.Metakey, wc.Metadata, wc.CreatedUserID, wc.CreatedTime, wc.ModifiedUserID, wc.ModifiedTime, wc.Hits, wc.Language, wc.Version, wc.ID)
	_, err = db.Exec(sqlstr, wc.AssetID, wc.ParentID, wc.Lft, wc.Rgt, wc.Level, wc.Path, wc.Extension, wc.Title, wc.Alias, wc.Note, wc.Description, wc.Published, wc.CheckedOut, wc.CheckedOutTime, wc.Access, wc.Params, wc.Metadesc, wc.Metakey, wc.Metadata, wc.CreatedUserID, wc.CreatedTime, wc.ModifiedUserID, wc.ModifiedTime, wc.Hits, wc.Language, wc.Version, wc.ID)
	return err
}

// Save saves the WsubCategory to the database.
func (wc *WsubCategory) Save(db XODB) error {
	if wc.Exists() {
		return wc.Update(db)
	}

	return wc.Insert(db)
}

// Delete deletes the WsubCategory from the database.
func (wc *WsubCategory) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wc._exists {
		return nil
	}

	// if deleted, bail
	if wc._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM jlabo.wsub_categories WHERE id = ?`

	// run query
	XOLog(sqlstr, wc.ID)
	_, err = db.Exec(sqlstr, wc.ID)
	if err != nil {
		return err
	}

	// set deleted
	wc._deleted = true

	return nil
}

// WsubCategoriesByExtensionPublishedAccess retrieves a row from 'jlabo.wsub_categories' as a WsubCategory.
//
// Generated from index 'cat_idx'.
func WsubCategoriesByExtensionPublishedAccess(db XODB, extension string, published bool, access uint) ([]*WsubCategory, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, parent_id, lft, rgt, level, path, extension, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, modified_user_id, modified_time, hits, language, version ` +
		`FROM jlabo.wsub_categories ` +
		`WHERE extension = ? AND published = ? AND access = ?`

	// run query
	XOLog(sqlstr, extension, published, access)
	q, err := db.Query(sqlstr, extension, published, access)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubCategory{}
	for q.Next() {
		wc := WsubCategory{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.ParentID, &wc.Lft, &wc.Rgt, &wc.Level, &wc.Path, &wc.Extension, &wc.Title, &wc.Alias, &wc.Note, &wc.Description, &wc.Published, &wc.CheckedOut, &wc.CheckedOutTime, &wc.Access, &wc.Params, &wc.Metadesc, &wc.Metakey, &wc.Metadata, &wc.CreatedUserID, &wc.CreatedTime, &wc.ModifiedUserID, &wc.ModifiedTime, &wc.Hits, &wc.Language, &wc.Version)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubCategoriesByAccess retrieves a row from 'jlabo.wsub_categories' as a WsubCategory.
//
// Generated from index 'idx_access'.
func WsubCategoriesByAccess(db XODB, access uint) ([]*WsubCategory, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, parent_id, lft, rgt, level, path, extension, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, modified_user_id, modified_time, hits, language, version ` +
		`FROM jlabo.wsub_categories ` +
		`WHERE access = ?`

	// run query
	XOLog(sqlstr, access)
	q, err := db.Query(sqlstr, access)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubCategory{}
	for q.Next() {
		wc := WsubCategory{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.ParentID, &wc.Lft, &wc.Rgt, &wc.Level, &wc.Path, &wc.Extension, &wc.Title, &wc.Alias, &wc.Note, &wc.Description, &wc.Published, &wc.CheckedOut, &wc.CheckedOutTime, &wc.Access, &wc.Params, &wc.Metadesc, &wc.Metakey, &wc.Metadata, &wc.CreatedUserID, &wc.CreatedTime, &wc.ModifiedUserID, &wc.ModifiedTime, &wc.Hits, &wc.Language, &wc.Version)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubCategoriesByAlias retrieves a row from 'jlabo.wsub_categories' as a WsubCategory.
//
// Generated from index 'idx_alias'.
func WsubCategoriesByAlias(db XODB, alias string) ([]*WsubCategory, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, parent_id, lft, rgt, level, path, extension, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, modified_user_id, modified_time, hits, language, version ` +
		`FROM jlabo.wsub_categories ` +
		`WHERE alias = ?`

	// run query
	XOLog(sqlstr, alias)
	q, err := db.Query(sqlstr, alias)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubCategory{}
	for q.Next() {
		wc := WsubCategory{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.ParentID, &wc.Lft, &wc.Rgt, &wc.Level, &wc.Path, &wc.Extension, &wc.Title, &wc.Alias, &wc.Note, &wc.Description, &wc.Published, &wc.CheckedOut, &wc.CheckedOutTime, &wc.Access, &wc.Params, &wc.Metadesc, &wc.Metakey, &wc.Metadata, &wc.CreatedUserID, &wc.CreatedTime, &wc.ModifiedUserID, &wc.ModifiedTime, &wc.Hits, &wc.Language, &wc.Version)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubCategoriesByCheckedOut retrieves a row from 'jlabo.wsub_categories' as a WsubCategory.
//
// Generated from index 'idx_checkout'.
func WsubCategoriesByCheckedOut(db XODB, checkedOut uint) ([]*WsubCategory, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, parent_id, lft, rgt, level, path, extension, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, modified_user_id, modified_time, hits, language, version ` +
		`FROM jlabo.wsub_categories ` +
		`WHERE checked_out = ?`

	// run query
	XOLog(sqlstr, checkedOut)
	q, err := db.Query(sqlstr, checkedOut)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubCategory{}
	for q.Next() {
		wc := WsubCategory{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.ParentID, &wc.Lft, &wc.Rgt, &wc.Level, &wc.Path, &wc.Extension, &wc.Title, &wc.Alias, &wc.Note, &wc.Description, &wc.Published, &wc.CheckedOut, &wc.CheckedOutTime, &wc.Access, &wc.Params, &wc.Metadesc, &wc.Metakey, &wc.Metadata, &wc.CreatedUserID, &wc.CreatedTime, &wc.ModifiedUserID, &wc.ModifiedTime, &wc.Hits, &wc.Language, &wc.Version)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubCategoriesByLanguage retrieves a row from 'jlabo.wsub_categories' as a WsubCategory.
//
// Generated from index 'idx_language'.
func WsubCategoriesByLanguage(db XODB, language string) ([]*WsubCategory, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, parent_id, lft, rgt, level, path, extension, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, modified_user_id, modified_time, hits, language, version ` +
		`FROM jlabo.wsub_categories ` +
		`WHERE language = ?`

	// run query
	XOLog(sqlstr, language)
	q, err := db.Query(sqlstr, language)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubCategory{}
	for q.Next() {
		wc := WsubCategory{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.ParentID, &wc.Lft, &wc.Rgt, &wc.Level, &wc.Path, &wc.Extension, &wc.Title, &wc.Alias, &wc.Note, &wc.Description, &wc.Published, &wc.CheckedOut, &wc.CheckedOutTime, &wc.Access, &wc.Params, &wc.Metadesc, &wc.Metakey, &wc.Metadata, &wc.CreatedUserID, &wc.CreatedTime, &wc.ModifiedUserID, &wc.ModifiedTime, &wc.Hits, &wc.Language, &wc.Version)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubCategoriesByLftRgt retrieves a row from 'jlabo.wsub_categories' as a WsubCategory.
//
// Generated from index 'idx_left_right'.
func WsubCategoriesByLftRgt(db XODB, lft int, rgt int) ([]*WsubCategory, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, parent_id, lft, rgt, level, path, extension, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, modified_user_id, modified_time, hits, language, version ` +
		`FROM jlabo.wsub_categories ` +
		`WHERE lft = ? AND rgt = ?`

	// run query
	XOLog(sqlstr, lft, rgt)
	q, err := db.Query(sqlstr, lft, rgt)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubCategory{}
	for q.Next() {
		wc := WsubCategory{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.ParentID, &wc.Lft, &wc.Rgt, &wc.Level, &wc.Path, &wc.Extension, &wc.Title, &wc.Alias, &wc.Note, &wc.Description, &wc.Published, &wc.CheckedOut, &wc.CheckedOutTime, &wc.Access, &wc.Params, &wc.Metadesc, &wc.Metakey, &wc.Metadata, &wc.CreatedUserID, &wc.CreatedTime, &wc.ModifiedUserID, &wc.ModifiedTime, &wc.Hits, &wc.Language, &wc.Version)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubCategoriesByPath retrieves a row from 'jlabo.wsub_categories' as a WsubCategory.
//
// Generated from index 'idx_path'.
func WsubCategoriesByPath(db XODB, path string) ([]*WsubCategory, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, parent_id, lft, rgt, level, path, extension, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, modified_user_id, modified_time, hits, language, version ` +
		`FROM jlabo.wsub_categories ` +
		`WHERE path = ?`

	// run query
	XOLog(sqlstr, path)
	q, err := db.Query(sqlstr, path)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubCategory{}
	for q.Next() {
		wc := WsubCategory{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.ParentID, &wc.Lft, &wc.Rgt, &wc.Level, &wc.Path, &wc.Extension, &wc.Title, &wc.Alias, &wc.Note, &wc.Description, &wc.Published, &wc.CheckedOut, &wc.CheckedOutTime, &wc.Access, &wc.Params, &wc.Metadesc, &wc.Metakey, &wc.Metadata, &wc.CreatedUserID, &wc.CreatedTime, &wc.ModifiedUserID, &wc.ModifiedTime, &wc.Hits, &wc.Language, &wc.Version)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubCategoryByID retrieves a row from 'jlabo.wsub_categories' as a WsubCategory.
//
// Generated from index 'wsub_categories_id_pkey'.
func WsubCategoryByID(db XODB, id int) (*WsubCategory, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, parent_id, lft, rgt, level, path, extension, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, modified_user_id, modified_time, hits, language, version ` +
		`FROM jlabo.wsub_categories ` +
		`WHERE id = ?`

	// run query
	XOLog(sqlstr, id)
	wc := WsubCategory{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&wc.ID, &wc.AssetID, &wc.ParentID, &wc.Lft, &wc.Rgt, &wc.Level, &wc.Path, &wc.Extension, &wc.Title, &wc.Alias, &wc.Note, &wc.Description, &wc.Published, &wc.CheckedOut, &wc.CheckedOutTime, &wc.Access, &wc.Params, &wc.Metadesc, &wc.Metakey, &wc.Metadata, &wc.CreatedUserID, &wc.CreatedTime, &wc.ModifiedUserID, &wc.ModifiedTime, &wc.Hits, &wc.Language, &wc.Version)
	if err != nil {
		return nil, err
	}

	return &wc, nil
}
