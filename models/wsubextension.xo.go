// Package toto contains the types for schema 'jlabo'.
package toto

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql"
	"errors"
	"time"
)

// WsubExtension represents a row from 'jlabo.wsub_extensions'.
type WsubExtension struct {
	ExtensionID    int           `json:"extension_id"`     // extension_id
	Name           string        `json:"name"`             // name
	Type           string        `json:"type"`             // type
	Element        string        `json:"element"`          // element
	Folder         string        `json:"folder"`           // folder
	ClientID       int8          `json:"client_id"`        // client_id
	Enabled        int8          `json:"enabled"`          // enabled
	Access         uint          `json:"access"`           // access
	Protected      int8          `json:"protected"`        // protected
	ManifestCache  string        `json:"manifest_cache"`   // manifest_cache
	Params         string        `json:"params"`           // params
	CustomData     string        `json:"custom_data"`      // custom_data
	SystemData     string        `json:"system_data"`      // system_data
	CheckedOut     uint          `json:"checked_out"`      // checked_out
	CheckedOutTime time.Time     `json:"checked_out_time"` // checked_out_time
	Ordering       sql.NullInt64 `json:"ordering"`         // ordering
	State          sql.NullInt64 `json:"state"`            // state

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the WsubExtension exists in the database.
func (we *WsubExtension) Exists() bool {
	return we._exists
}

// Deleted provides information if the WsubExtension has been deleted from the database.
func (we *WsubExtension) Deleted() bool {
	return we._deleted
}

// Insert inserts the WsubExtension to the database.
func (we *WsubExtension) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if we._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO jlabo.wsub_extensions (` +
		`name, type, element, folder, client_id, enabled, access, protected, manifest_cache, params, custom_data, system_data, checked_out, checked_out_time, ordering, state` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, we.Name, we.Type, we.Element, we.Folder, we.ClientID, we.Enabled, we.Access, we.Protected, we.ManifestCache, we.Params, we.CustomData, we.SystemData, we.CheckedOut, we.CheckedOutTime, we.Ordering, we.State)
	res, err := db.Exec(sqlstr, we.Name, we.Type, we.Element, we.Folder, we.ClientID, we.Enabled, we.Access, we.Protected, we.ManifestCache, we.Params, we.CustomData, we.SystemData, we.CheckedOut, we.CheckedOutTime, we.Ordering, we.State)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	we.ExtensionID = int(id)
	we._exists = true

	return nil
}

// Update updates the WsubExtension in the database.
func (we *WsubExtension) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !we._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if we._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE jlabo.wsub_extensions SET ` +
		`name = ?, type = ?, element = ?, folder = ?, client_id = ?, enabled = ?, access = ?, protected = ?, manifest_cache = ?, params = ?, custom_data = ?, system_data = ?, checked_out = ?, checked_out_time = ?, ordering = ?, state = ?` +
		` WHERE extension_id = ?`

	// run query
	XOLog(sqlstr, we.Name, we.Type, we.Element, we.Folder, we.ClientID, we.Enabled, we.Access, we.Protected, we.ManifestCache, we.Params, we.CustomData, we.SystemData, we.CheckedOut, we.CheckedOutTime, we.Ordering, we.State, we.ExtensionID)
	_, err = db.Exec(sqlstr, we.Name, we.Type, we.Element, we.Folder, we.ClientID, we.Enabled, we.Access, we.Protected, we.ManifestCache, we.Params, we.CustomData, we.SystemData, we.CheckedOut, we.CheckedOutTime, we.Ordering, we.State, we.ExtensionID)
	return err
}

// Save saves the WsubExtension to the database.
func (we *WsubExtension) Save(db XODB) error {
	if we.Exists() {
		return we.Update(db)
	}

	return we.Insert(db)
}

// Delete deletes the WsubExtension from the database.
func (we *WsubExtension) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !we._exists {
		return nil
	}

	// if deleted, bail
	if we._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM jlabo.wsub_extensions WHERE extension_id = ?`

	// run query
	XOLog(sqlstr, we.ExtensionID)
	_, err = db.Exec(sqlstr, we.ExtensionID)
	if err != nil {
		return err
	}

	// set deleted
	we._deleted = true

	return nil
}

// WsubExtensionsByElementClientID retrieves a row from 'jlabo.wsub_extensions' as a WsubExtension.
//
// Generated from index 'element_clientid'.
func WsubExtensionsByElementClientID(db XODB, element string, clientID int8) ([]*WsubExtension, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`extension_id, name, type, element, folder, client_id, enabled, access, protected, manifest_cache, params, custom_data, system_data, checked_out, checked_out_time, ordering, state ` +
		`FROM jlabo.wsub_extensions ` +
		`WHERE element = ? AND client_id = ?`

	// run query
	XOLog(sqlstr, element, clientID)
	q, err := db.Query(sqlstr, element, clientID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubExtension{}
	for q.Next() {
		we := WsubExtension{
			_exists: true,
		}

		// scan
		err = q.Scan(&we.ExtensionID, &we.Name, &we.Type, &we.Element, &we.Folder, &we.ClientID, &we.Enabled, &we.Access, &we.Protected, &we.ManifestCache, &we.Params, &we.CustomData, &we.SystemData, &we.CheckedOut, &we.CheckedOutTime, &we.Ordering, &we.State)
		if err != nil {
			return nil, err
		}

		res = append(res, &we)
	}

	return res, nil
}

// WsubExtensionsByElementFolderClientID retrieves a row from 'jlabo.wsub_extensions' as a WsubExtension.
//
// Generated from index 'element_folder_clientid'.
func WsubExtensionsByElementFolderClientID(db XODB, element string, folder string, clientID int8) ([]*WsubExtension, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`extension_id, name, type, element, folder, client_id, enabled, access, protected, manifest_cache, params, custom_data, system_data, checked_out, checked_out_time, ordering, state ` +
		`FROM jlabo.wsub_extensions ` +
		`WHERE element = ? AND folder = ? AND client_id = ?`

	// run query
	XOLog(sqlstr, element, folder, clientID)
	q, err := db.Query(sqlstr, element, folder, clientID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubExtension{}
	for q.Next() {
		we := WsubExtension{
			_exists: true,
		}

		// scan
		err = q.Scan(&we.ExtensionID, &we.Name, &we.Type, &we.Element, &we.Folder, &we.ClientID, &we.Enabled, &we.Access, &we.Protected, &we.ManifestCache, &we.Params, &we.CustomData, &we.SystemData, &we.CheckedOut, &we.CheckedOutTime, &we.Ordering, &we.State)
		if err != nil {
			return nil, err
		}

		res = append(res, &we)
	}

	return res, nil
}

// WsubExtensionsByTypeElementFolderClientID retrieves a row from 'jlabo.wsub_extensions' as a WsubExtension.
//
// Generated from index 'extension'.
func WsubExtensionsByTypeElementFolderClientID(db XODB, typ string, element string, folder string, clientID int8) ([]*WsubExtension, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`extension_id, name, type, element, folder, client_id, enabled, access, protected, manifest_cache, params, custom_data, system_data, checked_out, checked_out_time, ordering, state ` +
		`FROM jlabo.wsub_extensions ` +
		`WHERE type = ? AND element = ? AND folder = ? AND client_id = ?`

	// run query
	XOLog(sqlstr, typ, element, folder, clientID)
	q, err := db.Query(sqlstr, typ, element, folder, clientID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubExtension{}
	for q.Next() {
		we := WsubExtension{
			_exists: true,
		}

		// scan
		err = q.Scan(&we.ExtensionID, &we.Name, &we.Type, &we.Element, &we.Folder, &we.ClientID, &we.Enabled, &we.Access, &we.Protected, &we.ManifestCache, &we.Params, &we.CustomData, &we.SystemData, &we.CheckedOut, &we.CheckedOutTime, &we.Ordering, &we.State)
		if err != nil {
			return nil, err
		}

		res = append(res, &we)
	}

	return res, nil
}

// WsubExtensionByExtensionID retrieves a row from 'jlabo.wsub_extensions' as a WsubExtension.
//
// Generated from index 'wsub_extensions_extension_id_pkey'.
func WsubExtensionByExtensionID(db XODB, extensionID int) (*WsubExtension, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`extension_id, name, type, element, folder, client_id, enabled, access, protected, manifest_cache, params, custom_data, system_data, checked_out, checked_out_time, ordering, state ` +
		`FROM jlabo.wsub_extensions ` +
		`WHERE extension_id = ?`

	// run query
	XOLog(sqlstr, extensionID)
	we := WsubExtension{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, extensionID).Scan(&we.ExtensionID, &we.Name, &we.Type, &we.Element, &we.Folder, &we.ClientID, &we.Enabled, &we.Access, &we.Protected, &we.ManifestCache, &we.Params, &we.CustomData, &we.SystemData, &we.CheckedOut, &we.CheckedOutTime, &we.Ordering, &we.State)
	if err != nil {
		return nil, err
	}

	return &we, nil
}
