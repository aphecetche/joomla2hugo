// Package toto contains the types for schema 'jlabo'.
package toto

// Code generated by xo. DO NOT EDIT.

import (
	"errors"
	"time"
)

// WsubNewsfeed represents a row from 'jlabo.wsub_newsfeeds'.
type WsubNewsfeed struct {
	Catid          int       `json:"catid"`            // catid
	ID             uint      `json:"id"`               // id
	Name           string    `json:"name"`             // name
	Alias          string    `json:"alias"`            // alias
	Link           string    `json:"link"`             // link
	Published      bool      `json:"published"`        // published
	Numarticles    uint      `json:"numarticles"`      // numarticles
	CacheTime      uint      `json:"cache_time"`       // cache_time
	CheckedOut     uint      `json:"checked_out"`      // checked_out
	CheckedOutTime time.Time `json:"checked_out_time"` // checked_out_time
	Ordering       int       `json:"ordering"`         // ordering
	Rtl            int8      `json:"rtl"`              // rtl
	Access         uint      `json:"access"`           // access
	Language       string    `json:"language"`         // language
	Params         string    `json:"params"`           // params
	Created        time.Time `json:"created"`          // created
	CreatedBy      uint      `json:"created_by"`       // created_by
	CreatedByAlias string    `json:"created_by_alias"` // created_by_alias
	Modified       time.Time `json:"modified"`         // modified
	ModifiedBy     uint      `json:"modified_by"`      // modified_by
	Metakey        string    `json:"metakey"`          // metakey
	Metadesc       string    `json:"metadesc"`         // metadesc
	Metadata       string    `json:"metadata"`         // metadata
	Xreference     string    `json:"xreference"`       // xreference
	PublishUp      time.Time `json:"publish_up"`       // publish_up
	PublishDown    time.Time `json:"publish_down"`     // publish_down
	Description    string    `json:"description"`      // description
	Version        uint      `json:"version"`          // version
	Hits           uint      `json:"hits"`             // hits
	Images         string    `json:"images"`           // images

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the WsubNewsfeed exists in the database.
func (wn *WsubNewsfeed) Exists() bool {
	return wn._exists
}

// Deleted provides information if the WsubNewsfeed has been deleted from the database.
func (wn *WsubNewsfeed) Deleted() bool {
	return wn._deleted
}

// Insert inserts the WsubNewsfeed to the database.
func (wn *WsubNewsfeed) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if wn._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO jlabo.wsub_newsfeeds (` +
		`catid, name, alias, link, published, numarticles, cache_time, checked_out, checked_out_time, ordering, rtl, access, language, params, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, xreference, publish_up, publish_down, description, version, hits, images` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, wn.Catid, wn.Name, wn.Alias, wn.Link, wn.Published, wn.Numarticles, wn.CacheTime, wn.CheckedOut, wn.CheckedOutTime, wn.Ordering, wn.Rtl, wn.Access, wn.Language, wn.Params, wn.Created, wn.CreatedBy, wn.CreatedByAlias, wn.Modified, wn.ModifiedBy, wn.Metakey, wn.Metadesc, wn.Metadata, wn.Xreference, wn.PublishUp, wn.PublishDown, wn.Description, wn.Version, wn.Hits, wn.Images)
	res, err := db.Exec(sqlstr, wn.Catid, wn.Name, wn.Alias, wn.Link, wn.Published, wn.Numarticles, wn.CacheTime, wn.CheckedOut, wn.CheckedOutTime, wn.Ordering, wn.Rtl, wn.Access, wn.Language, wn.Params, wn.Created, wn.CreatedBy, wn.CreatedByAlias, wn.Modified, wn.ModifiedBy, wn.Metakey, wn.Metadesc, wn.Metadata, wn.Xreference, wn.PublishUp, wn.PublishDown, wn.Description, wn.Version, wn.Hits, wn.Images)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	wn.ID = uint(id)
	wn._exists = true

	return nil
}

// Update updates the WsubNewsfeed in the database.
func (wn *WsubNewsfeed) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wn._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if wn._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE jlabo.wsub_newsfeeds SET ` +
		`catid = ?, name = ?, alias = ?, link = ?, published = ?, numarticles = ?, cache_time = ?, checked_out = ?, checked_out_time = ?, ordering = ?, rtl = ?, access = ?, language = ?, params = ?, created = ?, created_by = ?, created_by_alias = ?, modified = ?, modified_by = ?, metakey = ?, metadesc = ?, metadata = ?, xreference = ?, publish_up = ?, publish_down = ?, description = ?, version = ?, hits = ?, images = ?` +
		` WHERE id = ?`

	// run query
	XOLog(sqlstr, wn.Catid, wn.Name, wn.Alias, wn.Link, wn.Published, wn.Numarticles, wn.CacheTime, wn.CheckedOut, wn.CheckedOutTime, wn.Ordering, wn.Rtl, wn.Access, wn.Language, wn.Params, wn.Created, wn.CreatedBy, wn.CreatedByAlias, wn.Modified, wn.ModifiedBy, wn.Metakey, wn.Metadesc, wn.Metadata, wn.Xreference, wn.PublishUp, wn.PublishDown, wn.Description, wn.Version, wn.Hits, wn.Images, wn.ID)
	_, err = db.Exec(sqlstr, wn.Catid, wn.Name, wn.Alias, wn.Link, wn.Published, wn.Numarticles, wn.CacheTime, wn.CheckedOut, wn.CheckedOutTime, wn.Ordering, wn.Rtl, wn.Access, wn.Language, wn.Params, wn.Created, wn.CreatedBy, wn.CreatedByAlias, wn.Modified, wn.ModifiedBy, wn.Metakey, wn.Metadesc, wn.Metadata, wn.Xreference, wn.PublishUp, wn.PublishDown, wn.Description, wn.Version, wn.Hits, wn.Images, wn.ID)
	return err
}

// Save saves the WsubNewsfeed to the database.
func (wn *WsubNewsfeed) Save(db XODB) error {
	if wn.Exists() {
		return wn.Update(db)
	}

	return wn.Insert(db)
}

// Delete deletes the WsubNewsfeed from the database.
func (wn *WsubNewsfeed) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wn._exists {
		return nil
	}

	// if deleted, bail
	if wn._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM jlabo.wsub_newsfeeds WHERE id = ?`

	// run query
	XOLog(sqlstr, wn.ID)
	_, err = db.Exec(sqlstr, wn.ID)
	if err != nil {
		return err
	}

	// set deleted
	wn._deleted = true

	return nil
}

// WsubNewsfeedsByAccess retrieves a row from 'jlabo.wsub_newsfeeds' as a WsubNewsfeed.
//
// Generated from index 'idx_access'.
func WsubNewsfeedsByAccess(db XODB, access uint) ([]*WsubNewsfeed, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`catid, id, name, alias, link, published, numarticles, cache_time, checked_out, checked_out_time, ordering, rtl, access, language, params, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, xreference, publish_up, publish_down, description, version, hits, images ` +
		`FROM jlabo.wsub_newsfeeds ` +
		`WHERE access = ?`

	// run query
	XOLog(sqlstr, access)
	q, err := db.Query(sqlstr, access)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubNewsfeed{}
	for q.Next() {
		wn := WsubNewsfeed{
			_exists: true,
		}

		// scan
		err = q.Scan(&wn.Catid, &wn.ID, &wn.Name, &wn.Alias, &wn.Link, &wn.Published, &wn.Numarticles, &wn.CacheTime, &wn.CheckedOut, &wn.CheckedOutTime, &wn.Ordering, &wn.Rtl, &wn.Access, &wn.Language, &wn.Params, &wn.Created, &wn.CreatedBy, &wn.CreatedByAlias, &wn.Modified, &wn.ModifiedBy, &wn.Metakey, &wn.Metadesc, &wn.Metadata, &wn.Xreference, &wn.PublishUp, &wn.PublishDown, &wn.Description, &wn.Version, &wn.Hits, &wn.Images)
		if err != nil {
			return nil, err
		}

		res = append(res, &wn)
	}

	return res, nil
}

// WsubNewsfeedsByCatid retrieves a row from 'jlabo.wsub_newsfeeds' as a WsubNewsfeed.
//
// Generated from index 'idx_catid'.
func WsubNewsfeedsByCatid(db XODB, catid int) ([]*WsubNewsfeed, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`catid, id, name, alias, link, published, numarticles, cache_time, checked_out, checked_out_time, ordering, rtl, access, language, params, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, xreference, publish_up, publish_down, description, version, hits, images ` +
		`FROM jlabo.wsub_newsfeeds ` +
		`WHERE catid = ?`

	// run query
	XOLog(sqlstr, catid)
	q, err := db.Query(sqlstr, catid)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubNewsfeed{}
	for q.Next() {
		wn := WsubNewsfeed{
			_exists: true,
		}

		// scan
		err = q.Scan(&wn.Catid, &wn.ID, &wn.Name, &wn.Alias, &wn.Link, &wn.Published, &wn.Numarticles, &wn.CacheTime, &wn.CheckedOut, &wn.CheckedOutTime, &wn.Ordering, &wn.Rtl, &wn.Access, &wn.Language, &wn.Params, &wn.Created, &wn.CreatedBy, &wn.CreatedByAlias, &wn.Modified, &wn.ModifiedBy, &wn.Metakey, &wn.Metadesc, &wn.Metadata, &wn.Xreference, &wn.PublishUp, &wn.PublishDown, &wn.Description, &wn.Version, &wn.Hits, &wn.Images)
		if err != nil {
			return nil, err
		}

		res = append(res, &wn)
	}

	return res, nil
}

// WsubNewsfeedsByCheckedOut retrieves a row from 'jlabo.wsub_newsfeeds' as a WsubNewsfeed.
//
// Generated from index 'idx_checkout'.
func WsubNewsfeedsByCheckedOut(db XODB, checkedOut uint) ([]*WsubNewsfeed, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`catid, id, name, alias, link, published, numarticles, cache_time, checked_out, checked_out_time, ordering, rtl, access, language, params, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, xreference, publish_up, publish_down, description, version, hits, images ` +
		`FROM jlabo.wsub_newsfeeds ` +
		`WHERE checked_out = ?`

	// run query
	XOLog(sqlstr, checkedOut)
	q, err := db.Query(sqlstr, checkedOut)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubNewsfeed{}
	for q.Next() {
		wn := WsubNewsfeed{
			_exists: true,
		}

		// scan
		err = q.Scan(&wn.Catid, &wn.ID, &wn.Name, &wn.Alias, &wn.Link, &wn.Published, &wn.Numarticles, &wn.CacheTime, &wn.CheckedOut, &wn.CheckedOutTime, &wn.Ordering, &wn.Rtl, &wn.Access, &wn.Language, &wn.Params, &wn.Created, &wn.CreatedBy, &wn.CreatedByAlias, &wn.Modified, &wn.ModifiedBy, &wn.Metakey, &wn.Metadesc, &wn.Metadata, &wn.Xreference, &wn.PublishUp, &wn.PublishDown, &wn.Description, &wn.Version, &wn.Hits, &wn.Images)
		if err != nil {
			return nil, err
		}

		res = append(res, &wn)
	}

	return res, nil
}

// WsubNewsfeedsByCreatedBy retrieves a row from 'jlabo.wsub_newsfeeds' as a WsubNewsfeed.
//
// Generated from index 'idx_createdby'.
func WsubNewsfeedsByCreatedBy(db XODB, createdBy uint) ([]*WsubNewsfeed, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`catid, id, name, alias, link, published, numarticles, cache_time, checked_out, checked_out_time, ordering, rtl, access, language, params, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, xreference, publish_up, publish_down, description, version, hits, images ` +
		`FROM jlabo.wsub_newsfeeds ` +
		`WHERE created_by = ?`

	// run query
	XOLog(sqlstr, createdBy)
	q, err := db.Query(sqlstr, createdBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubNewsfeed{}
	for q.Next() {
		wn := WsubNewsfeed{
			_exists: true,
		}

		// scan
		err = q.Scan(&wn.Catid, &wn.ID, &wn.Name, &wn.Alias, &wn.Link, &wn.Published, &wn.Numarticles, &wn.CacheTime, &wn.CheckedOut, &wn.CheckedOutTime, &wn.Ordering, &wn.Rtl, &wn.Access, &wn.Language, &wn.Params, &wn.Created, &wn.CreatedBy, &wn.CreatedByAlias, &wn.Modified, &wn.ModifiedBy, &wn.Metakey, &wn.Metadesc, &wn.Metadata, &wn.Xreference, &wn.PublishUp, &wn.PublishDown, &wn.Description, &wn.Version, &wn.Hits, &wn.Images)
		if err != nil {
			return nil, err
		}

		res = append(res, &wn)
	}

	return res, nil
}

// WsubNewsfeedsByLanguage retrieves a row from 'jlabo.wsub_newsfeeds' as a WsubNewsfeed.
//
// Generated from index 'idx_language'.
func WsubNewsfeedsByLanguage(db XODB, language string) ([]*WsubNewsfeed, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`catid, id, name, alias, link, published, numarticles, cache_time, checked_out, checked_out_time, ordering, rtl, access, language, params, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, xreference, publish_up, publish_down, description, version, hits, images ` +
		`FROM jlabo.wsub_newsfeeds ` +
		`WHERE language = ?`

	// run query
	XOLog(sqlstr, language)
	q, err := db.Query(sqlstr, language)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubNewsfeed{}
	for q.Next() {
		wn := WsubNewsfeed{
			_exists: true,
		}

		// scan
		err = q.Scan(&wn.Catid, &wn.ID, &wn.Name, &wn.Alias, &wn.Link, &wn.Published, &wn.Numarticles, &wn.CacheTime, &wn.CheckedOut, &wn.CheckedOutTime, &wn.Ordering, &wn.Rtl, &wn.Access, &wn.Language, &wn.Params, &wn.Created, &wn.CreatedBy, &wn.CreatedByAlias, &wn.Modified, &wn.ModifiedBy, &wn.Metakey, &wn.Metadesc, &wn.Metadata, &wn.Xreference, &wn.PublishUp, &wn.PublishDown, &wn.Description, &wn.Version, &wn.Hits, &wn.Images)
		if err != nil {
			return nil, err
		}

		res = append(res, &wn)
	}

	return res, nil
}

// WsubNewsfeedsByPublished retrieves a row from 'jlabo.wsub_newsfeeds' as a WsubNewsfeed.
//
// Generated from index 'idx_state'.
func WsubNewsfeedsByPublished(db XODB, published bool) ([]*WsubNewsfeed, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`catid, id, name, alias, link, published, numarticles, cache_time, checked_out, checked_out_time, ordering, rtl, access, language, params, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, xreference, publish_up, publish_down, description, version, hits, images ` +
		`FROM jlabo.wsub_newsfeeds ` +
		`WHERE published = ?`

	// run query
	XOLog(sqlstr, published)
	q, err := db.Query(sqlstr, published)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubNewsfeed{}
	for q.Next() {
		wn := WsubNewsfeed{
			_exists: true,
		}

		// scan
		err = q.Scan(&wn.Catid, &wn.ID, &wn.Name, &wn.Alias, &wn.Link, &wn.Published, &wn.Numarticles, &wn.CacheTime, &wn.CheckedOut, &wn.CheckedOutTime, &wn.Ordering, &wn.Rtl, &wn.Access, &wn.Language, &wn.Params, &wn.Created, &wn.CreatedBy, &wn.CreatedByAlias, &wn.Modified, &wn.ModifiedBy, &wn.Metakey, &wn.Metadesc, &wn.Metadata, &wn.Xreference, &wn.PublishUp, &wn.PublishDown, &wn.Description, &wn.Version, &wn.Hits, &wn.Images)
		if err != nil {
			return nil, err
		}

		res = append(res, &wn)
	}

	return res, nil
}

// WsubNewsfeedsByXreference retrieves a row from 'jlabo.wsub_newsfeeds' as a WsubNewsfeed.
//
// Generated from index 'idx_xreference'.
func WsubNewsfeedsByXreference(db XODB, xreference string) ([]*WsubNewsfeed, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`catid, id, name, alias, link, published, numarticles, cache_time, checked_out, checked_out_time, ordering, rtl, access, language, params, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, xreference, publish_up, publish_down, description, version, hits, images ` +
		`FROM jlabo.wsub_newsfeeds ` +
		`WHERE xreference = ?`

	// run query
	XOLog(sqlstr, xreference)
	q, err := db.Query(sqlstr, xreference)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubNewsfeed{}
	for q.Next() {
		wn := WsubNewsfeed{
			_exists: true,
		}

		// scan
		err = q.Scan(&wn.Catid, &wn.ID, &wn.Name, &wn.Alias, &wn.Link, &wn.Published, &wn.Numarticles, &wn.CacheTime, &wn.CheckedOut, &wn.CheckedOutTime, &wn.Ordering, &wn.Rtl, &wn.Access, &wn.Language, &wn.Params, &wn.Created, &wn.CreatedBy, &wn.CreatedByAlias, &wn.Modified, &wn.ModifiedBy, &wn.Metakey, &wn.Metadesc, &wn.Metadata, &wn.Xreference, &wn.PublishUp, &wn.PublishDown, &wn.Description, &wn.Version, &wn.Hits, &wn.Images)
		if err != nil {
			return nil, err
		}

		res = append(res, &wn)
	}

	return res, nil
}

// WsubNewsfeedByID retrieves a row from 'jlabo.wsub_newsfeeds' as a WsubNewsfeed.
//
// Generated from index 'wsub_newsfeeds_id_pkey'.
func WsubNewsfeedByID(db XODB, id uint) (*WsubNewsfeed, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`catid, id, name, alias, link, published, numarticles, cache_time, checked_out, checked_out_time, ordering, rtl, access, language, params, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, xreference, publish_up, publish_down, description, version, hits, images ` +
		`FROM jlabo.wsub_newsfeeds ` +
		`WHERE id = ?`

	// run query
	XOLog(sqlstr, id)
	wn := WsubNewsfeed{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&wn.Catid, &wn.ID, &wn.Name, &wn.Alias, &wn.Link, &wn.Published, &wn.Numarticles, &wn.CacheTime, &wn.CheckedOut, &wn.CheckedOutTime, &wn.Ordering, &wn.Rtl, &wn.Access, &wn.Language, &wn.Params, &wn.Created, &wn.CreatedBy, &wn.CreatedByAlias, &wn.Modified, &wn.ModifiedBy, &wn.Metakey, &wn.Metadesc, &wn.Metadata, &wn.Xreference, &wn.PublishUp, &wn.PublishDown, &wn.Description, &wn.Version, &wn.Hits, &wn.Images)
	if err != nil {
		return nil, err
	}

	return &wn, nil
}
