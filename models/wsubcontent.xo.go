// Package toto contains the types for schema 'jlabo'.
package toto

// Code generated by xo. DO NOT EDIT.

import (
	"errors"
	"time"
)

// WsubContent represents a row from 'jlabo.wsub_content'.
type WsubContent struct {
	ID             uint      `json:"id"`               // id
	AssetID        uint      `json:"asset_id"`         // asset_id
	Title          string    `json:"title"`            // title
	Alias          string    `json:"alias"`            // alias
	Introtext      string    `json:"introtext"`        // introtext
	Fulltext       string    `json:"fulltext"`         // fulltext
	State          int8      `json:"state"`            // state
	Catid          uint      `json:"catid"`            // catid
	Created        time.Time `json:"created"`          // created
	CreatedBy      uint      `json:"created_by"`       // created_by
	CreatedByAlias string    `json:"created_by_alias"` // created_by_alias
	Modified       time.Time `json:"modified"`         // modified
	ModifiedBy     uint      `json:"modified_by"`      // modified_by
	CheckedOut     uint      `json:"checked_out"`      // checked_out
	CheckedOutTime time.Time `json:"checked_out_time"` // checked_out_time
	PublishUp      time.Time `json:"publish_up"`       // publish_up
	PublishDown    time.Time `json:"publish_down"`     // publish_down
	Images         string    `json:"images"`           // images
	Urls           string    `json:"urls"`             // urls
	Attribs        string    `json:"attribs"`          // attribs
	Version        uint      `json:"version"`          // version
	Ordering       int       `json:"ordering"`         // ordering
	Metakey        string    `json:"metakey"`          // metakey
	Metadesc       string    `json:"metadesc"`         // metadesc
	Access         uint      `json:"access"`           // access
	Hits           uint      `json:"hits"`             // hits
	Metadata       string    `json:"metadata"`         // metadata
	Featured       int8      `json:"featured"`         // featured
	Language       string    `json:"language"`         // language
	Xreference     string    `json:"xreference"`       // xreference

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the WsubContent exists in the database.
func (wc *WsubContent) Exists() bool {
	return wc._exists
}

// Deleted provides information if the WsubContent has been deleted from the database.
func (wc *WsubContent) Deleted() bool {
	return wc._deleted
}

// Insert inserts the WsubContent to the database.
func (wc *WsubContent) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if wc._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO jlabo.wsub_content (` +
		`asset_id, title, alias, introtext, fulltext, state, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, ordering, metakey, metadesc, access, hits, metadata, featured, language, xreference` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, wc.AssetID, wc.Title, wc.Alias, wc.Introtext, wc.Fulltext, wc.State, wc.Catid, wc.Created, wc.CreatedBy, wc.CreatedByAlias, wc.Modified, wc.ModifiedBy, wc.CheckedOut, wc.CheckedOutTime, wc.PublishUp, wc.PublishDown, wc.Images, wc.Urls, wc.Attribs, wc.Version, wc.Ordering, wc.Metakey, wc.Metadesc, wc.Access, wc.Hits, wc.Metadata, wc.Featured, wc.Language, wc.Xreference)
	res, err := db.Exec(sqlstr, wc.AssetID, wc.Title, wc.Alias, wc.Introtext, wc.Fulltext, wc.State, wc.Catid, wc.Created, wc.CreatedBy, wc.CreatedByAlias, wc.Modified, wc.ModifiedBy, wc.CheckedOut, wc.CheckedOutTime, wc.PublishUp, wc.PublishDown, wc.Images, wc.Urls, wc.Attribs, wc.Version, wc.Ordering, wc.Metakey, wc.Metadesc, wc.Access, wc.Hits, wc.Metadata, wc.Featured, wc.Language, wc.Xreference)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	wc.ID = uint(id)
	wc._exists = true

	return nil
}

// Update updates the WsubContent in the database.
func (wc *WsubContent) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wc._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if wc._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE jlabo.wsub_content SET ` +
		`asset_id = ?, title = ?, alias = ?, introtext = ?, fulltext = ?, state = ?, catid = ?, created = ?, created_by = ?, created_by_alias = ?, modified = ?, modified_by = ?, checked_out = ?, checked_out_time = ?, publish_up = ?, publish_down = ?, images = ?, urls = ?, attribs = ?, version = ?, ordering = ?, metakey = ?, metadesc = ?, access = ?, hits = ?, metadata = ?, featured = ?, language = ?, xreference = ?` +
		` WHERE id = ?`

	// run query
	XOLog(sqlstr, wc.AssetID, wc.Title, wc.Alias, wc.Introtext, wc.Fulltext, wc.State, wc.Catid, wc.Created, wc.CreatedBy, wc.CreatedByAlias, wc.Modified, wc.ModifiedBy, wc.CheckedOut, wc.CheckedOutTime, wc.PublishUp, wc.PublishDown, wc.Images, wc.Urls, wc.Attribs, wc.Version, wc.Ordering, wc.Metakey, wc.Metadesc, wc.Access, wc.Hits, wc.Metadata, wc.Featured, wc.Language, wc.Xreference, wc.ID)
	_, err = db.Exec(sqlstr, wc.AssetID, wc.Title, wc.Alias, wc.Introtext, wc.Fulltext, wc.State, wc.Catid, wc.Created, wc.CreatedBy, wc.CreatedByAlias, wc.Modified, wc.ModifiedBy, wc.CheckedOut, wc.CheckedOutTime, wc.PublishUp, wc.PublishDown, wc.Images, wc.Urls, wc.Attribs, wc.Version, wc.Ordering, wc.Metakey, wc.Metadesc, wc.Access, wc.Hits, wc.Metadata, wc.Featured, wc.Language, wc.Xreference, wc.ID)
	return err
}

// Save saves the WsubContent to the database.
func (wc *WsubContent) Save(db XODB) error {
	if wc.Exists() {
		return wc.Update(db)
	}

	return wc.Insert(db)
}

// Delete deletes the WsubContent from the database.
func (wc *WsubContent) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wc._exists {
		return nil
	}

	// if deleted, bail
	if wc._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM jlabo.wsub_content WHERE id = ?`

	// run query
	XOLog(sqlstr, wc.ID)
	_, err = db.Exec(sqlstr, wc.ID)
	if err != nil {
		return err
	}

	// set deleted
	wc._deleted = true

	return nil
}

// WsubContentsByAccess retrieves a row from 'jlabo.wsub_content' as a WsubContent.
//
// Generated from index 'idx_access'.
func WsubContentsByAccess(db XODB, access uint) ([]*WsubContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, title, alias, introtext, fulltext, state, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, ordering, metakey, metadesc, access, hits, metadata, featured, language, xreference ` +
		`FROM jlabo.wsub_content ` +
		`WHERE access = ?`

	// run query
	XOLog(sqlstr, access)
	q, err := db.Query(sqlstr, access)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContent{}
	for q.Next() {
		wc := WsubContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.Title, &wc.Alias, &wc.Introtext, &wc.Fulltext, &wc.State, &wc.Catid, &wc.Created, &wc.CreatedBy, &wc.CreatedByAlias, &wc.Modified, &wc.ModifiedBy, &wc.CheckedOut, &wc.CheckedOutTime, &wc.PublishUp, &wc.PublishDown, &wc.Images, &wc.Urls, &wc.Attribs, &wc.Version, &wc.Ordering, &wc.Metakey, &wc.Metadesc, &wc.Access, &wc.Hits, &wc.Metadata, &wc.Featured, &wc.Language, &wc.Xreference)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubContentsByCatid retrieves a row from 'jlabo.wsub_content' as a WsubContent.
//
// Generated from index 'idx_catid'.
func WsubContentsByCatid(db XODB, catid uint) ([]*WsubContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, title, alias, introtext, fulltext, state, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, ordering, metakey, metadesc, access, hits, metadata, featured, language, xreference ` +
		`FROM jlabo.wsub_content ` +
		`WHERE catid = ?`

	// run query
	XOLog(sqlstr, catid)
	q, err := db.Query(sqlstr, catid)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContent{}
	for q.Next() {
		wc := WsubContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.Title, &wc.Alias, &wc.Introtext, &wc.Fulltext, &wc.State, &wc.Catid, &wc.Created, &wc.CreatedBy, &wc.CreatedByAlias, &wc.Modified, &wc.ModifiedBy, &wc.CheckedOut, &wc.CheckedOutTime, &wc.PublishUp, &wc.PublishDown, &wc.Images, &wc.Urls, &wc.Attribs, &wc.Version, &wc.Ordering, &wc.Metakey, &wc.Metadesc, &wc.Access, &wc.Hits, &wc.Metadata, &wc.Featured, &wc.Language, &wc.Xreference)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubContentsByCheckedOut retrieves a row from 'jlabo.wsub_content' as a WsubContent.
//
// Generated from index 'idx_checkout'.
func WsubContentsByCheckedOut(db XODB, checkedOut uint) ([]*WsubContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, title, alias, introtext, fulltext, state, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, ordering, metakey, metadesc, access, hits, metadata, featured, language, xreference ` +
		`FROM jlabo.wsub_content ` +
		`WHERE checked_out = ?`

	// run query
	XOLog(sqlstr, checkedOut)
	q, err := db.Query(sqlstr, checkedOut)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContent{}
	for q.Next() {
		wc := WsubContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.Title, &wc.Alias, &wc.Introtext, &wc.Fulltext, &wc.State, &wc.Catid, &wc.Created, &wc.CreatedBy, &wc.CreatedByAlias, &wc.Modified, &wc.ModifiedBy, &wc.CheckedOut, &wc.CheckedOutTime, &wc.PublishUp, &wc.PublishDown, &wc.Images, &wc.Urls, &wc.Attribs, &wc.Version, &wc.Ordering, &wc.Metakey, &wc.Metadesc, &wc.Access, &wc.Hits, &wc.Metadata, &wc.Featured, &wc.Language, &wc.Xreference)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubContentsByCreatedBy retrieves a row from 'jlabo.wsub_content' as a WsubContent.
//
// Generated from index 'idx_createdby'.
func WsubContentsByCreatedBy(db XODB, createdBy uint) ([]*WsubContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, title, alias, introtext, fulltext, state, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, ordering, metakey, metadesc, access, hits, metadata, featured, language, xreference ` +
		`FROM jlabo.wsub_content ` +
		`WHERE created_by = ?`

	// run query
	XOLog(sqlstr, createdBy)
	q, err := db.Query(sqlstr, createdBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContent{}
	for q.Next() {
		wc := WsubContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.Title, &wc.Alias, &wc.Introtext, &wc.Fulltext, &wc.State, &wc.Catid, &wc.Created, &wc.CreatedBy, &wc.CreatedByAlias, &wc.Modified, &wc.ModifiedBy, &wc.CheckedOut, &wc.CheckedOutTime, &wc.PublishUp, &wc.PublishDown, &wc.Images, &wc.Urls, &wc.Attribs, &wc.Version, &wc.Ordering, &wc.Metakey, &wc.Metadesc, &wc.Access, &wc.Hits, &wc.Metadata, &wc.Featured, &wc.Language, &wc.Xreference)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubContentsByFeaturedCatid retrieves a row from 'jlabo.wsub_content' as a WsubContent.
//
// Generated from index 'idx_featured_catid'.
func WsubContentsByFeaturedCatid(db XODB, featured int8, catid uint) ([]*WsubContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, title, alias, introtext, fulltext, state, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, ordering, metakey, metadesc, access, hits, metadata, featured, language, xreference ` +
		`FROM jlabo.wsub_content ` +
		`WHERE featured = ? AND catid = ?`

	// run query
	XOLog(sqlstr, featured, catid)
	q, err := db.Query(sqlstr, featured, catid)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContent{}
	for q.Next() {
		wc := WsubContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.Title, &wc.Alias, &wc.Introtext, &wc.Fulltext, &wc.State, &wc.Catid, &wc.Created, &wc.CreatedBy, &wc.CreatedByAlias, &wc.Modified, &wc.ModifiedBy, &wc.CheckedOut, &wc.CheckedOutTime, &wc.PublishUp, &wc.PublishDown, &wc.Images, &wc.Urls, &wc.Attribs, &wc.Version, &wc.Ordering, &wc.Metakey, &wc.Metadesc, &wc.Access, &wc.Hits, &wc.Metadata, &wc.Featured, &wc.Language, &wc.Xreference)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubContentsByLanguage retrieves a row from 'jlabo.wsub_content' as a WsubContent.
//
// Generated from index 'idx_language'.
func WsubContentsByLanguage(db XODB, language string) ([]*WsubContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, title, alias, introtext, fulltext, state, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, ordering, metakey, metadesc, access, hits, metadata, featured, language, xreference ` +
		`FROM jlabo.wsub_content ` +
		`WHERE language = ?`

	// run query
	XOLog(sqlstr, language)
	q, err := db.Query(sqlstr, language)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContent{}
	for q.Next() {
		wc := WsubContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.Title, &wc.Alias, &wc.Introtext, &wc.Fulltext, &wc.State, &wc.Catid, &wc.Created, &wc.CreatedBy, &wc.CreatedByAlias, &wc.Modified, &wc.ModifiedBy, &wc.CheckedOut, &wc.CheckedOutTime, &wc.PublishUp, &wc.PublishDown, &wc.Images, &wc.Urls, &wc.Attribs, &wc.Version, &wc.Ordering, &wc.Metakey, &wc.Metadesc, &wc.Access, &wc.Hits, &wc.Metadata, &wc.Featured, &wc.Language, &wc.Xreference)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubContentsByState retrieves a row from 'jlabo.wsub_content' as a WsubContent.
//
// Generated from index 'idx_state'.
func WsubContentsByState(db XODB, state int8) ([]*WsubContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, title, alias, introtext, fulltext, state, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, ordering, metakey, metadesc, access, hits, metadata, featured, language, xreference ` +
		`FROM jlabo.wsub_content ` +
		`WHERE state = ?`

	// run query
	XOLog(sqlstr, state)
	q, err := db.Query(sqlstr, state)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContent{}
	for q.Next() {
		wc := WsubContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.Title, &wc.Alias, &wc.Introtext, &wc.Fulltext, &wc.State, &wc.Catid, &wc.Created, &wc.CreatedBy, &wc.CreatedByAlias, &wc.Modified, &wc.ModifiedBy, &wc.CheckedOut, &wc.CheckedOutTime, &wc.PublishUp, &wc.PublishDown, &wc.Images, &wc.Urls, &wc.Attribs, &wc.Version, &wc.Ordering, &wc.Metakey, &wc.Metadesc, &wc.Access, &wc.Hits, &wc.Metadata, &wc.Featured, &wc.Language, &wc.Xreference)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubContentsByXreference retrieves a row from 'jlabo.wsub_content' as a WsubContent.
//
// Generated from index 'idx_xreference'.
func WsubContentsByXreference(db XODB, xreference string) ([]*WsubContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, title, alias, introtext, fulltext, state, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, ordering, metakey, metadesc, access, hits, metadata, featured, language, xreference ` +
		`FROM jlabo.wsub_content ` +
		`WHERE xreference = ?`

	// run query
	XOLog(sqlstr, xreference)
	q, err := db.Query(sqlstr, xreference)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContent{}
	for q.Next() {
		wc := WsubContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wc.ID, &wc.AssetID, &wc.Title, &wc.Alias, &wc.Introtext, &wc.Fulltext, &wc.State, &wc.Catid, &wc.Created, &wc.CreatedBy, &wc.CreatedByAlias, &wc.Modified, &wc.ModifiedBy, &wc.CheckedOut, &wc.CheckedOutTime, &wc.PublishUp, &wc.PublishDown, &wc.Images, &wc.Urls, &wc.Attribs, &wc.Version, &wc.Ordering, &wc.Metakey, &wc.Metadesc, &wc.Access, &wc.Hits, &wc.Metadata, &wc.Featured, &wc.Language, &wc.Xreference)
		if err != nil {
			return nil, err
		}

		res = append(res, &wc)
	}

	return res, nil
}

// WsubContentByID retrieves a row from 'jlabo.wsub_content' as a WsubContent.
//
// Generated from index 'wsub_content_id_pkey'.
func WsubContentByID(db XODB, id uint) (*WsubContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, asset_id, title, alias, introtext, fulltext, state, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, ordering, metakey, metadesc, access, hits, metadata, featured, language, xreference ` +
		`FROM jlabo.wsub_content ` +
		`WHERE id = ?`

	// run query
	XOLog(sqlstr, id)
	wc := WsubContent{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&wc.ID, &wc.AssetID, &wc.Title, &wc.Alias, &wc.Introtext, &wc.Fulltext, &wc.State, &wc.Catid, &wc.Created, &wc.CreatedBy, &wc.CreatedByAlias, &wc.Modified, &wc.ModifiedBy, &wc.CheckedOut, &wc.CheckedOutTime, &wc.PublishUp, &wc.PublishDown, &wc.Images, &wc.Urls, &wc.Attribs, &wc.Version, &wc.Ordering, &wc.Metakey, &wc.Metadesc, &wc.Access, &wc.Hits, &wc.Metadata, &wc.Featured, &wc.Language, &wc.Xreference)
	if err != nil {
		return nil, err
	}

	return &wc, nil
}
