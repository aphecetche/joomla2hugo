// Package toto contains the types for schema 'jlabo'.
package toto

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql"
	"errors"

	"github.com/go-sql-driver/mysql"
)

// WsubVersion represents a row from 'jlabo.wsub_version'.
type WsubVersion struct {
	ID             float64         `json:"id"`               // id
	Title          sql.NullString  `json:"title"`            // title
	Alias          sql.NullString  `json:"alias"`            // alias
	TitleAlias     sql.NullString  `json:"title_alias"`      // title_alias
	Introtext      []byte          `json:"introtext"`        // introtext
	Fulltext       []byte          `json:"fulltext"`         // fulltext
	State          sql.NullInt64   `json:"state"`            // state
	Sectionid      sql.NullFloat64 `json:"sectionid"`        // sectionid
	Mask           sql.NullFloat64 `json:"mask"`             // mask
	Catid          sql.NullFloat64 `json:"catid"`            // catid
	Created        mysql.NullTime  `json:"created"`          // created
	CreatedBy      sql.NullFloat64 `json:"created_by"`       // created_by
	CreatedByAlias sql.NullString  `json:"created_by_alias"` // created_by_alias
	Modified       mysql.NullTime  `json:"modified"`         // modified
	ModifiedBy     sql.NullFloat64 `json:"modified_by"`      // modified_by
	CheckedOut     sql.NullFloat64 `json:"checked_out"`      // checked_out
	CheckedOutTime mysql.NullTime  `json:"checked_out_time"` // checked_out_time
	PublishUp      mysql.NullTime  `json:"publish_up"`       // publish_up
	PublishDown    mysql.NullTime  `json:"publish_down"`     // publish_down
	Images         []byte          `json:"images"`           // images
	Urls           []byte          `json:"urls"`             // urls
	Attribs        []byte          `json:"attribs"`          // attribs
	Version        sql.NullFloat64 `json:"version"`          // version
	Parentid       sql.NullFloat64 `json:"parentid"`         // parentid
	Ordering       sql.NullFloat64 `json:"ordering"`         // ordering
	Metakey        []byte          `json:"metakey"`          // metakey
	Metadesc       []byte          `json:"metadesc"`         // metadesc
	Access         sql.NullFloat64 `json:"access"`           // access
	Hits           sql.NullFloat64 `json:"hits"`             // hits
	Metadata       []byte          `json:"metadata"`         // metadata
	ContentID      sql.NullFloat64 `json:"content_id"`       // content_id
	LanguageID     sql.NullFloat64 `json:"language_id"`      // language_id
	Stage          sql.NullFloat64 `json:"stage"`            // stage
	Autosaved      sql.NullFloat64 `json:"autosaved"`        // autosaved
	Featured       sql.NullInt64   `json:"featured"`         // featured
	Xreference     sql.NullString  `json:"xreference"`       // xreference
	Language       sql.NullString  `json:"language"`         // language
	AssetID        sql.NullInt64   `json:"asset_id"`         // asset_id

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the WsubVersion exists in the database.
func (wv *WsubVersion) Exists() bool {
	return wv._exists
}

// Deleted provides information if the WsubVersion has been deleted from the database.
func (wv *WsubVersion) Deleted() bool {
	return wv._deleted
}

// Insert inserts the WsubVersion to the database.
func (wv *WsubVersion) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if wv._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO jlabo.wsub_version (` +
		`title, alias, title_alias, introtext, fulltext, state, sectionid, mask, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, parentid, ordering, metakey, metadesc, access, hits, metadata, content_id, language_id, stage, autosaved, featured, xreference, language, asset_id` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, wv.Title, wv.Alias, wv.TitleAlias, wv.Introtext, wv.Fulltext, wv.State, wv.Sectionid, wv.Mask, wv.Catid, wv.Created, wv.CreatedBy, wv.CreatedByAlias, wv.Modified, wv.ModifiedBy, wv.CheckedOut, wv.CheckedOutTime, wv.PublishUp, wv.PublishDown, wv.Images, wv.Urls, wv.Attribs, wv.Version, wv.Parentid, wv.Ordering, wv.Metakey, wv.Metadesc, wv.Access, wv.Hits, wv.Metadata, wv.ContentID, wv.LanguageID, wv.Stage, wv.Autosaved, wv.Featured, wv.Xreference, wv.Language, wv.AssetID)
	res, err := db.Exec(sqlstr, wv.Title, wv.Alias, wv.TitleAlias, wv.Introtext, wv.Fulltext, wv.State, wv.Sectionid, wv.Mask, wv.Catid, wv.Created, wv.CreatedBy, wv.CreatedByAlias, wv.Modified, wv.ModifiedBy, wv.CheckedOut, wv.CheckedOutTime, wv.PublishUp, wv.PublishDown, wv.Images, wv.Urls, wv.Attribs, wv.Version, wv.Parentid, wv.Ordering, wv.Metakey, wv.Metadesc, wv.Access, wv.Hits, wv.Metadata, wv.ContentID, wv.LanguageID, wv.Stage, wv.Autosaved, wv.Featured, wv.Xreference, wv.Language, wv.AssetID)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	wv.ID = float64(id)
	wv._exists = true

	return nil
}

// Update updates the WsubVersion in the database.
func (wv *WsubVersion) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wv._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if wv._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE jlabo.wsub_version SET ` +
		`title = ?, alias = ?, title_alias = ?, introtext = ?, fulltext = ?, state = ?, sectionid = ?, mask = ?, catid = ?, created = ?, created_by = ?, created_by_alias = ?, modified = ?, modified_by = ?, checked_out = ?, checked_out_time = ?, publish_up = ?, publish_down = ?, images = ?, urls = ?, attribs = ?, version = ?, parentid = ?, ordering = ?, metakey = ?, metadesc = ?, access = ?, hits = ?, metadata = ?, content_id = ?, language_id = ?, stage = ?, autosaved = ?, featured = ?, xreference = ?, language = ?, asset_id = ?` +
		` WHERE id = ?`

	// run query
	XOLog(sqlstr, wv.Title, wv.Alias, wv.TitleAlias, wv.Introtext, wv.Fulltext, wv.State, wv.Sectionid, wv.Mask, wv.Catid, wv.Created, wv.CreatedBy, wv.CreatedByAlias, wv.Modified, wv.ModifiedBy, wv.CheckedOut, wv.CheckedOutTime, wv.PublishUp, wv.PublishDown, wv.Images, wv.Urls, wv.Attribs, wv.Version, wv.Parentid, wv.Ordering, wv.Metakey, wv.Metadesc, wv.Access, wv.Hits, wv.Metadata, wv.ContentID, wv.LanguageID, wv.Stage, wv.Autosaved, wv.Featured, wv.Xreference, wv.Language, wv.AssetID, wv.ID)
	_, err = db.Exec(sqlstr, wv.Title, wv.Alias, wv.TitleAlias, wv.Introtext, wv.Fulltext, wv.State, wv.Sectionid, wv.Mask, wv.Catid, wv.Created, wv.CreatedBy, wv.CreatedByAlias, wv.Modified, wv.ModifiedBy, wv.CheckedOut, wv.CheckedOutTime, wv.PublishUp, wv.PublishDown, wv.Images, wv.Urls, wv.Attribs, wv.Version, wv.Parentid, wv.Ordering, wv.Metakey, wv.Metadesc, wv.Access, wv.Hits, wv.Metadata, wv.ContentID, wv.LanguageID, wv.Stage, wv.Autosaved, wv.Featured, wv.Xreference, wv.Language, wv.AssetID, wv.ID)
	return err
}

// Save saves the WsubVersion to the database.
func (wv *WsubVersion) Save(db XODB) error {
	if wv.Exists() {
		return wv.Update(db)
	}

	return wv.Insert(db)
}

// Delete deletes the WsubVersion from the database.
func (wv *WsubVersion) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wv._exists {
		return nil
	}

	// if deleted, bail
	if wv._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM jlabo.wsub_version WHERE id = ?`

	// run query
	XOLog(sqlstr, wv.ID)
	_, err = db.Exec(sqlstr, wv.ID)
	if err != nil {
		return err
	}

	// set deleted
	wv._deleted = true

	return nil
}

// WsubVersionsByContentID retrieves a row from 'jlabo.wsub_version' as a WsubVersion.
//
// Generated from index 'idx_content_id'.
func WsubVersionsByContentID(db XODB, contentID sql.NullFloat64) ([]*WsubVersion, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, title, alias, title_alias, introtext, fulltext, state, sectionid, mask, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, parentid, ordering, metakey, metadesc, access, hits, metadata, content_id, language_id, stage, autosaved, featured, xreference, language, asset_id ` +
		`FROM jlabo.wsub_version ` +
		`WHERE content_id = ?`

	// run query
	XOLog(sqlstr, contentID)
	q, err := db.Query(sqlstr, contentID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubVersion{}
	for q.Next() {
		wv := WsubVersion{
			_exists: true,
		}

		// scan
		err = q.Scan(&wv.ID, &wv.Title, &wv.Alias, &wv.TitleAlias, &wv.Introtext, &wv.Fulltext, &wv.State, &wv.Sectionid, &wv.Mask, &wv.Catid, &wv.Created, &wv.CreatedBy, &wv.CreatedByAlias, &wv.Modified, &wv.ModifiedBy, &wv.CheckedOut, &wv.CheckedOutTime, &wv.PublishUp, &wv.PublishDown, &wv.Images, &wv.Urls, &wv.Attribs, &wv.Version, &wv.Parentid, &wv.Ordering, &wv.Metakey, &wv.Metadesc, &wv.Access, &wv.Hits, &wv.Metadata, &wv.ContentID, &wv.LanguageID, &wv.Stage, &wv.Autosaved, &wv.Featured, &wv.Xreference, &wv.Language, &wv.AssetID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wv)
	}

	return res, nil
}

// WsubVersionByID retrieves a row from 'jlabo.wsub_version' as a WsubVersion.
//
// Generated from index 'wsub_version_id_pkey'.
func WsubVersionByID(db XODB, id float64) (*WsubVersion, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, title, alias, title_alias, introtext, fulltext, state, sectionid, mask, catid, created, created_by, created_by_alias, modified, modified_by, checked_out, checked_out_time, publish_up, publish_down, images, urls, attribs, version, parentid, ordering, metakey, metadesc, access, hits, metadata, content_id, language_id, stage, autosaved, featured, xreference, language, asset_id ` +
		`FROM jlabo.wsub_version ` +
		`WHERE id = ?`

	// run query
	XOLog(sqlstr, id)
	wv := WsubVersion{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&wv.ID, &wv.Title, &wv.Alias, &wv.TitleAlias, &wv.Introtext, &wv.Fulltext, &wv.State, &wv.Sectionid, &wv.Mask, &wv.Catid, &wv.Created, &wv.CreatedBy, &wv.CreatedByAlias, &wv.Modified, &wv.ModifiedBy, &wv.CheckedOut, &wv.CheckedOutTime, &wv.PublishUp, &wv.PublishDown, &wv.Images, &wv.Urls, &wv.Attribs, &wv.Version, &wv.Parentid, &wv.Ordering, &wv.Metakey, &wv.Metadesc, &wv.Access, &wv.Hits, &wv.Metadata, &wv.ContentID, &wv.LanguageID, &wv.Stage, &wv.Autosaved, &wv.Featured, &wv.Xreference, &wv.Language, &wv.AssetID)
	if err != nil {
		return nil, err
	}

	return &wv, nil
}
