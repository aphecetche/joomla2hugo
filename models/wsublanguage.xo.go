// Package toto contains the types for schema 'jlabo'.
package toto

// Code generated by xo. DO NOT EDIT.

import (
	"errors"
)

// WsubLanguage represents a row from 'jlabo.wsub_languages'.
type WsubLanguage struct {
	LangID      uint   `json:"lang_id"`      // lang_id
	LangCode    string `json:"lang_code"`    // lang_code
	Title       string `json:"title"`        // title
	TitleNative string `json:"title_native"` // title_native
	Sef         string `json:"sef"`          // sef
	Image       string `json:"image"`        // image
	Description string `json:"description"`  // description
	Metakey     string `json:"metakey"`      // metakey
	Metadesc    string `json:"metadesc"`     // metadesc
	Sitename    string `json:"sitename"`     // sitename
	Published   int    `json:"published"`    // published
	Access      uint   `json:"access"`       // access
	Ordering    int    `json:"ordering"`     // ordering

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the WsubLanguage exists in the database.
func (wl *WsubLanguage) Exists() bool {
	return wl._exists
}

// Deleted provides information if the WsubLanguage has been deleted from the database.
func (wl *WsubLanguage) Deleted() bool {
	return wl._deleted
}

// Insert inserts the WsubLanguage to the database.
func (wl *WsubLanguage) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if wl._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO jlabo.wsub_languages (` +
		`lang_code, title, title_native, sef, image, description, metakey, metadesc, sitename, published, access, ordering` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, wl.LangCode, wl.Title, wl.TitleNative, wl.Sef, wl.Image, wl.Description, wl.Metakey, wl.Metadesc, wl.Sitename, wl.Published, wl.Access, wl.Ordering)
	res, err := db.Exec(sqlstr, wl.LangCode, wl.Title, wl.TitleNative, wl.Sef, wl.Image, wl.Description, wl.Metakey, wl.Metadesc, wl.Sitename, wl.Published, wl.Access, wl.Ordering)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	wl.LangID = uint(id)
	wl._exists = true

	return nil
}

// Update updates the WsubLanguage in the database.
func (wl *WsubLanguage) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wl._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if wl._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE jlabo.wsub_languages SET ` +
		`lang_code = ?, title = ?, title_native = ?, sef = ?, image = ?, description = ?, metakey = ?, metadesc = ?, sitename = ?, published = ?, access = ?, ordering = ?` +
		` WHERE lang_id = ?`

	// run query
	XOLog(sqlstr, wl.LangCode, wl.Title, wl.TitleNative, wl.Sef, wl.Image, wl.Description, wl.Metakey, wl.Metadesc, wl.Sitename, wl.Published, wl.Access, wl.Ordering, wl.LangID)
	_, err = db.Exec(sqlstr, wl.LangCode, wl.Title, wl.TitleNative, wl.Sef, wl.Image, wl.Description, wl.Metakey, wl.Metadesc, wl.Sitename, wl.Published, wl.Access, wl.Ordering, wl.LangID)
	return err
}

// Save saves the WsubLanguage to the database.
func (wl *WsubLanguage) Save(db XODB) error {
	if wl.Exists() {
		return wl.Update(db)
	}

	return wl.Insert(db)
}

// Delete deletes the WsubLanguage from the database.
func (wl *WsubLanguage) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wl._exists {
		return nil
	}

	// if deleted, bail
	if wl._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM jlabo.wsub_languages WHERE lang_id = ?`

	// run query
	XOLog(sqlstr, wl.LangID)
	_, err = db.Exec(sqlstr, wl.LangID)
	if err != nil {
		return err
	}

	// set deleted
	wl._deleted = true

	return nil
}

// WsubLanguagesByAccess retrieves a row from 'jlabo.wsub_languages' as a WsubLanguage.
//
// Generated from index 'idx_access'.
func WsubLanguagesByAccess(db XODB, access uint) ([]*WsubLanguage, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`lang_id, lang_code, title, title_native, sef, image, description, metakey, metadesc, sitename, published, access, ordering ` +
		`FROM jlabo.wsub_languages ` +
		`WHERE access = ?`

	// run query
	XOLog(sqlstr, access)
	q, err := db.Query(sqlstr, access)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubLanguage{}
	for q.Next() {
		wl := WsubLanguage{
			_exists: true,
		}

		// scan
		err = q.Scan(&wl.LangID, &wl.LangCode, &wl.Title, &wl.TitleNative, &wl.Sef, &wl.Image, &wl.Description, &wl.Metakey, &wl.Metadesc, &wl.Sitename, &wl.Published, &wl.Access, &wl.Ordering)
		if err != nil {
			return nil, err
		}

		res = append(res, &wl)
	}

	return res, nil
}

// WsubLanguageByImage retrieves a row from 'jlabo.wsub_languages' as a WsubLanguage.
//
// Generated from index 'idx_image'.
func WsubLanguageByImage(db XODB, image string) (*WsubLanguage, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`lang_id, lang_code, title, title_native, sef, image, description, metakey, metadesc, sitename, published, access, ordering ` +
		`FROM jlabo.wsub_languages ` +
		`WHERE image = ?`

	// run query
	XOLog(sqlstr, image)
	wl := WsubLanguage{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, image).Scan(&wl.LangID, &wl.LangCode, &wl.Title, &wl.TitleNative, &wl.Sef, &wl.Image, &wl.Description, &wl.Metakey, &wl.Metadesc, &wl.Sitename, &wl.Published, &wl.Access, &wl.Ordering)
	if err != nil {
		return nil, err
	}

	return &wl, nil
}

// WsubLanguageByLangCode retrieves a row from 'jlabo.wsub_languages' as a WsubLanguage.
//
// Generated from index 'idx_langcode'.
func WsubLanguageByLangCode(db XODB, langCode string) (*WsubLanguage, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`lang_id, lang_code, title, title_native, sef, image, description, metakey, metadesc, sitename, published, access, ordering ` +
		`FROM jlabo.wsub_languages ` +
		`WHERE lang_code = ?`

	// run query
	XOLog(sqlstr, langCode)
	wl := WsubLanguage{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, langCode).Scan(&wl.LangID, &wl.LangCode, &wl.Title, &wl.TitleNative, &wl.Sef, &wl.Image, &wl.Description, &wl.Metakey, &wl.Metadesc, &wl.Sitename, &wl.Published, &wl.Access, &wl.Ordering)
	if err != nil {
		return nil, err
	}

	return &wl, nil
}

// WsubLanguagesByOrdering retrieves a row from 'jlabo.wsub_languages' as a WsubLanguage.
//
// Generated from index 'idx_ordering'.
func WsubLanguagesByOrdering(db XODB, ordering int) ([]*WsubLanguage, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`lang_id, lang_code, title, title_native, sef, image, description, metakey, metadesc, sitename, published, access, ordering ` +
		`FROM jlabo.wsub_languages ` +
		`WHERE ordering = ?`

	// run query
	XOLog(sqlstr, ordering)
	q, err := db.Query(sqlstr, ordering)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubLanguage{}
	for q.Next() {
		wl := WsubLanguage{
			_exists: true,
		}

		// scan
		err = q.Scan(&wl.LangID, &wl.LangCode, &wl.Title, &wl.TitleNative, &wl.Sef, &wl.Image, &wl.Description, &wl.Metakey, &wl.Metadesc, &wl.Sitename, &wl.Published, &wl.Access, &wl.Ordering)
		if err != nil {
			return nil, err
		}

		res = append(res, &wl)
	}

	return res, nil
}

// WsubLanguageBySef retrieves a row from 'jlabo.wsub_languages' as a WsubLanguage.
//
// Generated from index 'idx_sef'.
func WsubLanguageBySef(db XODB, sef string) (*WsubLanguage, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`lang_id, lang_code, title, title_native, sef, image, description, metakey, metadesc, sitename, published, access, ordering ` +
		`FROM jlabo.wsub_languages ` +
		`WHERE sef = ?`

	// run query
	XOLog(sqlstr, sef)
	wl := WsubLanguage{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, sef).Scan(&wl.LangID, &wl.LangCode, &wl.Title, &wl.TitleNative, &wl.Sef, &wl.Image, &wl.Description, &wl.Metakey, &wl.Metadesc, &wl.Sitename, &wl.Published, &wl.Access, &wl.Ordering)
	if err != nil {
		return nil, err
	}

	return &wl, nil
}

// WsubLanguageByLangID retrieves a row from 'jlabo.wsub_languages' as a WsubLanguage.
//
// Generated from index 'wsub_languages_lang_id_pkey'.
func WsubLanguageByLangID(db XODB, langID uint) (*WsubLanguage, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`lang_id, lang_code, title, title_native, sef, image, description, metakey, metadesc, sitename, published, access, ordering ` +
		`FROM jlabo.wsub_languages ` +
		`WHERE lang_id = ?`

	// run query
	XOLog(sqlstr, langID)
	wl := WsubLanguage{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, langID).Scan(&wl.LangID, &wl.LangCode, &wl.Title, &wl.TitleNative, &wl.Sef, &wl.Image, &wl.Description, &wl.Metakey, &wl.Metadesc, &wl.Sitename, &wl.Published, &wl.Access, &wl.Ordering)
	if err != nil {
		return nil, err
	}

	return &wl, nil
}
