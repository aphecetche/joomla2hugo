// Package toto contains the types for schema 'jlabo'.
package toto

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql"
	"errors"
	"time"
)

// WsubContactDetail represents a row from 'jlabo.wsub_contact_details'.
type WsubContactDetail struct {
	ID             int            `json:"id"`               // id
	Name           string         `json:"name"`             // name
	Alias          string         `json:"alias"`            // alias
	ConPosition    sql.NullString `json:"con_position"`     // con_position
	Address        sql.NullString `json:"address"`          // address
	Suburb         sql.NullString `json:"suburb"`           // suburb
	State          sql.NullString `json:"state"`            // state
	Country        sql.NullString `json:"country"`          // country
	Postcode       sql.NullString `json:"postcode"`         // postcode
	Telephone      sql.NullString `json:"telephone"`        // telephone
	Fax            sql.NullString `json:"fax"`              // fax
	Misc           sql.NullString `json:"misc"`             // misc
	Image          sql.NullString `json:"image"`            // image
	EmailTo        sql.NullString `json:"email_to"`         // email_to
	DefaultCon     bool           `json:"default_con"`      // default_con
	Published      bool           `json:"published"`        // published
	CheckedOut     uint           `json:"checked_out"`      // checked_out
	CheckedOutTime time.Time      `json:"checked_out_time"` // checked_out_time
	Ordering       int            `json:"ordering"`         // ordering
	Params         string         `json:"params"`           // params
	UserID         int            `json:"user_id"`          // user_id
	Catid          int            `json:"catid"`            // catid
	Access         uint           `json:"access"`           // access
	Mobile         string         `json:"mobile"`           // mobile
	Webpage        string         `json:"webpage"`          // webpage
	Sortname1      string         `json:"sortname1"`        // sortname1
	Sortname2      string         `json:"sortname2"`        // sortname2
	Sortname3      string         `json:"sortname3"`        // sortname3
	Language       string         `json:"language"`         // language
	Created        time.Time      `json:"created"`          // created
	CreatedBy      uint           `json:"created_by"`       // created_by
	CreatedByAlias string         `json:"created_by_alias"` // created_by_alias
	Modified       time.Time      `json:"modified"`         // modified
	ModifiedBy     uint           `json:"modified_by"`      // modified_by
	Metakey        string         `json:"metakey"`          // metakey
	Metadesc       string         `json:"metadesc"`         // metadesc
	Metadata       string         `json:"metadata"`         // metadata
	Featured       int8           `json:"featured"`         // featured
	Xreference     string         `json:"xreference"`       // xreference
	PublishUp      time.Time      `json:"publish_up"`       // publish_up
	PublishDown    time.Time      `json:"publish_down"`     // publish_down
	Version        uint           `json:"version"`          // version
	Hits           uint           `json:"hits"`             // hits

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the WsubContactDetail exists in the database.
func (wcd *WsubContactDetail) Exists() bool {
	return wcd._exists
}

// Deleted provides information if the WsubContactDetail has been deleted from the database.
func (wcd *WsubContactDetail) Deleted() bool {
	return wcd._deleted
}

// Insert inserts the WsubContactDetail to the database.
func (wcd *WsubContactDetail) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if wcd._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO jlabo.wsub_contact_details (` +
		`name, alias, con_position, address, suburb, state, country, postcode, telephone, fax, misc, image, email_to, default_con, published, checked_out, checked_out_time, ordering, params, user_id, catid, access, mobile, webpage, sortname1, sortname2, sortname3, language, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, featured, xreference, publish_up, publish_down, version, hits` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, wcd.Name, wcd.Alias, wcd.ConPosition, wcd.Address, wcd.Suburb, wcd.State, wcd.Country, wcd.Postcode, wcd.Telephone, wcd.Fax, wcd.Misc, wcd.Image, wcd.EmailTo, wcd.DefaultCon, wcd.Published, wcd.CheckedOut, wcd.CheckedOutTime, wcd.Ordering, wcd.Params, wcd.UserID, wcd.Catid, wcd.Access, wcd.Mobile, wcd.Webpage, wcd.Sortname1, wcd.Sortname2, wcd.Sortname3, wcd.Language, wcd.Created, wcd.CreatedBy, wcd.CreatedByAlias, wcd.Modified, wcd.ModifiedBy, wcd.Metakey, wcd.Metadesc, wcd.Metadata, wcd.Featured, wcd.Xreference, wcd.PublishUp, wcd.PublishDown, wcd.Version, wcd.Hits)
	res, err := db.Exec(sqlstr, wcd.Name, wcd.Alias, wcd.ConPosition, wcd.Address, wcd.Suburb, wcd.State, wcd.Country, wcd.Postcode, wcd.Telephone, wcd.Fax, wcd.Misc, wcd.Image, wcd.EmailTo, wcd.DefaultCon, wcd.Published, wcd.CheckedOut, wcd.CheckedOutTime, wcd.Ordering, wcd.Params, wcd.UserID, wcd.Catid, wcd.Access, wcd.Mobile, wcd.Webpage, wcd.Sortname1, wcd.Sortname2, wcd.Sortname3, wcd.Language, wcd.Created, wcd.CreatedBy, wcd.CreatedByAlias, wcd.Modified, wcd.ModifiedBy, wcd.Metakey, wcd.Metadesc, wcd.Metadata, wcd.Featured, wcd.Xreference, wcd.PublishUp, wcd.PublishDown, wcd.Version, wcd.Hits)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	wcd.ID = int(id)
	wcd._exists = true

	return nil
}

// Update updates the WsubContactDetail in the database.
func (wcd *WsubContactDetail) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wcd._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if wcd._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE jlabo.wsub_contact_details SET ` +
		`name = ?, alias = ?, con_position = ?, address = ?, suburb = ?, state = ?, country = ?, postcode = ?, telephone = ?, fax = ?, misc = ?, image = ?, email_to = ?, default_con = ?, published = ?, checked_out = ?, checked_out_time = ?, ordering = ?, params = ?, user_id = ?, catid = ?, access = ?, mobile = ?, webpage = ?, sortname1 = ?, sortname2 = ?, sortname3 = ?, language = ?, created = ?, created_by = ?, created_by_alias = ?, modified = ?, modified_by = ?, metakey = ?, metadesc = ?, metadata = ?, featured = ?, xreference = ?, publish_up = ?, publish_down = ?, version = ?, hits = ?` +
		` WHERE id = ?`

	// run query
	XOLog(sqlstr, wcd.Name, wcd.Alias, wcd.ConPosition, wcd.Address, wcd.Suburb, wcd.State, wcd.Country, wcd.Postcode, wcd.Telephone, wcd.Fax, wcd.Misc, wcd.Image, wcd.EmailTo, wcd.DefaultCon, wcd.Published, wcd.CheckedOut, wcd.CheckedOutTime, wcd.Ordering, wcd.Params, wcd.UserID, wcd.Catid, wcd.Access, wcd.Mobile, wcd.Webpage, wcd.Sortname1, wcd.Sortname2, wcd.Sortname3, wcd.Language, wcd.Created, wcd.CreatedBy, wcd.CreatedByAlias, wcd.Modified, wcd.ModifiedBy, wcd.Metakey, wcd.Metadesc, wcd.Metadata, wcd.Featured, wcd.Xreference, wcd.PublishUp, wcd.PublishDown, wcd.Version, wcd.Hits, wcd.ID)
	_, err = db.Exec(sqlstr, wcd.Name, wcd.Alias, wcd.ConPosition, wcd.Address, wcd.Suburb, wcd.State, wcd.Country, wcd.Postcode, wcd.Telephone, wcd.Fax, wcd.Misc, wcd.Image, wcd.EmailTo, wcd.DefaultCon, wcd.Published, wcd.CheckedOut, wcd.CheckedOutTime, wcd.Ordering, wcd.Params, wcd.UserID, wcd.Catid, wcd.Access, wcd.Mobile, wcd.Webpage, wcd.Sortname1, wcd.Sortname2, wcd.Sortname3, wcd.Language, wcd.Created, wcd.CreatedBy, wcd.CreatedByAlias, wcd.Modified, wcd.ModifiedBy, wcd.Metakey, wcd.Metadesc, wcd.Metadata, wcd.Featured, wcd.Xreference, wcd.PublishUp, wcd.PublishDown, wcd.Version, wcd.Hits, wcd.ID)
	return err
}

// Save saves the WsubContactDetail to the database.
func (wcd *WsubContactDetail) Save(db XODB) error {
	if wcd.Exists() {
		return wcd.Update(db)
	}

	return wcd.Insert(db)
}

// Delete deletes the WsubContactDetail from the database.
func (wcd *WsubContactDetail) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wcd._exists {
		return nil
	}

	// if deleted, bail
	if wcd._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM jlabo.wsub_contact_details WHERE id = ?`

	// run query
	XOLog(sqlstr, wcd.ID)
	_, err = db.Exec(sqlstr, wcd.ID)
	if err != nil {
		return err
	}

	// set deleted
	wcd._deleted = true

	return nil
}

// WsubContactDetailsByAccess retrieves a row from 'jlabo.wsub_contact_details' as a WsubContactDetail.
//
// Generated from index 'idx_access'.
func WsubContactDetailsByAccess(db XODB, access uint) ([]*WsubContactDetail, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, name, alias, con_position, address, suburb, state, country, postcode, telephone, fax, misc, image, email_to, default_con, published, checked_out, checked_out_time, ordering, params, user_id, catid, access, mobile, webpage, sortname1, sortname2, sortname3, language, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, featured, xreference, publish_up, publish_down, version, hits ` +
		`FROM jlabo.wsub_contact_details ` +
		`WHERE access = ?`

	// run query
	XOLog(sqlstr, access)
	q, err := db.Query(sqlstr, access)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContactDetail{}
	for q.Next() {
		wcd := WsubContactDetail{
			_exists: true,
		}

		// scan
		err = q.Scan(&wcd.ID, &wcd.Name, &wcd.Alias, &wcd.ConPosition, &wcd.Address, &wcd.Suburb, &wcd.State, &wcd.Country, &wcd.Postcode, &wcd.Telephone, &wcd.Fax, &wcd.Misc, &wcd.Image, &wcd.EmailTo, &wcd.DefaultCon, &wcd.Published, &wcd.CheckedOut, &wcd.CheckedOutTime, &wcd.Ordering, &wcd.Params, &wcd.UserID, &wcd.Catid, &wcd.Access, &wcd.Mobile, &wcd.Webpage, &wcd.Sortname1, &wcd.Sortname2, &wcd.Sortname3, &wcd.Language, &wcd.Created, &wcd.CreatedBy, &wcd.CreatedByAlias, &wcd.Modified, &wcd.ModifiedBy, &wcd.Metakey, &wcd.Metadesc, &wcd.Metadata, &wcd.Featured, &wcd.Xreference, &wcd.PublishUp, &wcd.PublishDown, &wcd.Version, &wcd.Hits)
		if err != nil {
			return nil, err
		}

		res = append(res, &wcd)
	}

	return res, nil
}

// WsubContactDetailsByCatid retrieves a row from 'jlabo.wsub_contact_details' as a WsubContactDetail.
//
// Generated from index 'idx_catid'.
func WsubContactDetailsByCatid(db XODB, catid int) ([]*WsubContactDetail, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, name, alias, con_position, address, suburb, state, country, postcode, telephone, fax, misc, image, email_to, default_con, published, checked_out, checked_out_time, ordering, params, user_id, catid, access, mobile, webpage, sortname1, sortname2, sortname3, language, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, featured, xreference, publish_up, publish_down, version, hits ` +
		`FROM jlabo.wsub_contact_details ` +
		`WHERE catid = ?`

	// run query
	XOLog(sqlstr, catid)
	q, err := db.Query(sqlstr, catid)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContactDetail{}
	for q.Next() {
		wcd := WsubContactDetail{
			_exists: true,
		}

		// scan
		err = q.Scan(&wcd.ID, &wcd.Name, &wcd.Alias, &wcd.ConPosition, &wcd.Address, &wcd.Suburb, &wcd.State, &wcd.Country, &wcd.Postcode, &wcd.Telephone, &wcd.Fax, &wcd.Misc, &wcd.Image, &wcd.EmailTo, &wcd.DefaultCon, &wcd.Published, &wcd.CheckedOut, &wcd.CheckedOutTime, &wcd.Ordering, &wcd.Params, &wcd.UserID, &wcd.Catid, &wcd.Access, &wcd.Mobile, &wcd.Webpage, &wcd.Sortname1, &wcd.Sortname2, &wcd.Sortname3, &wcd.Language, &wcd.Created, &wcd.CreatedBy, &wcd.CreatedByAlias, &wcd.Modified, &wcd.ModifiedBy, &wcd.Metakey, &wcd.Metadesc, &wcd.Metadata, &wcd.Featured, &wcd.Xreference, &wcd.PublishUp, &wcd.PublishDown, &wcd.Version, &wcd.Hits)
		if err != nil {
			return nil, err
		}

		res = append(res, &wcd)
	}

	return res, nil
}

// WsubContactDetailsByCheckedOut retrieves a row from 'jlabo.wsub_contact_details' as a WsubContactDetail.
//
// Generated from index 'idx_checkout'.
func WsubContactDetailsByCheckedOut(db XODB, checkedOut uint) ([]*WsubContactDetail, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, name, alias, con_position, address, suburb, state, country, postcode, telephone, fax, misc, image, email_to, default_con, published, checked_out, checked_out_time, ordering, params, user_id, catid, access, mobile, webpage, sortname1, sortname2, sortname3, language, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, featured, xreference, publish_up, publish_down, version, hits ` +
		`FROM jlabo.wsub_contact_details ` +
		`WHERE checked_out = ?`

	// run query
	XOLog(sqlstr, checkedOut)
	q, err := db.Query(sqlstr, checkedOut)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContactDetail{}
	for q.Next() {
		wcd := WsubContactDetail{
			_exists: true,
		}

		// scan
		err = q.Scan(&wcd.ID, &wcd.Name, &wcd.Alias, &wcd.ConPosition, &wcd.Address, &wcd.Suburb, &wcd.State, &wcd.Country, &wcd.Postcode, &wcd.Telephone, &wcd.Fax, &wcd.Misc, &wcd.Image, &wcd.EmailTo, &wcd.DefaultCon, &wcd.Published, &wcd.CheckedOut, &wcd.CheckedOutTime, &wcd.Ordering, &wcd.Params, &wcd.UserID, &wcd.Catid, &wcd.Access, &wcd.Mobile, &wcd.Webpage, &wcd.Sortname1, &wcd.Sortname2, &wcd.Sortname3, &wcd.Language, &wcd.Created, &wcd.CreatedBy, &wcd.CreatedByAlias, &wcd.Modified, &wcd.ModifiedBy, &wcd.Metakey, &wcd.Metadesc, &wcd.Metadata, &wcd.Featured, &wcd.Xreference, &wcd.PublishUp, &wcd.PublishDown, &wcd.Version, &wcd.Hits)
		if err != nil {
			return nil, err
		}

		res = append(res, &wcd)
	}

	return res, nil
}

// WsubContactDetailsByCreatedBy retrieves a row from 'jlabo.wsub_contact_details' as a WsubContactDetail.
//
// Generated from index 'idx_createdby'.
func WsubContactDetailsByCreatedBy(db XODB, createdBy uint) ([]*WsubContactDetail, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, name, alias, con_position, address, suburb, state, country, postcode, telephone, fax, misc, image, email_to, default_con, published, checked_out, checked_out_time, ordering, params, user_id, catid, access, mobile, webpage, sortname1, sortname2, sortname3, language, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, featured, xreference, publish_up, publish_down, version, hits ` +
		`FROM jlabo.wsub_contact_details ` +
		`WHERE created_by = ?`

	// run query
	XOLog(sqlstr, createdBy)
	q, err := db.Query(sqlstr, createdBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContactDetail{}
	for q.Next() {
		wcd := WsubContactDetail{
			_exists: true,
		}

		// scan
		err = q.Scan(&wcd.ID, &wcd.Name, &wcd.Alias, &wcd.ConPosition, &wcd.Address, &wcd.Suburb, &wcd.State, &wcd.Country, &wcd.Postcode, &wcd.Telephone, &wcd.Fax, &wcd.Misc, &wcd.Image, &wcd.EmailTo, &wcd.DefaultCon, &wcd.Published, &wcd.CheckedOut, &wcd.CheckedOutTime, &wcd.Ordering, &wcd.Params, &wcd.UserID, &wcd.Catid, &wcd.Access, &wcd.Mobile, &wcd.Webpage, &wcd.Sortname1, &wcd.Sortname2, &wcd.Sortname3, &wcd.Language, &wcd.Created, &wcd.CreatedBy, &wcd.CreatedByAlias, &wcd.Modified, &wcd.ModifiedBy, &wcd.Metakey, &wcd.Metadesc, &wcd.Metadata, &wcd.Featured, &wcd.Xreference, &wcd.PublishUp, &wcd.PublishDown, &wcd.Version, &wcd.Hits)
		if err != nil {
			return nil, err
		}

		res = append(res, &wcd)
	}

	return res, nil
}

// WsubContactDetailsByFeaturedCatid retrieves a row from 'jlabo.wsub_contact_details' as a WsubContactDetail.
//
// Generated from index 'idx_featured_catid'.
func WsubContactDetailsByFeaturedCatid(db XODB, featured int8, catid int) ([]*WsubContactDetail, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, name, alias, con_position, address, suburb, state, country, postcode, telephone, fax, misc, image, email_to, default_con, published, checked_out, checked_out_time, ordering, params, user_id, catid, access, mobile, webpage, sortname1, sortname2, sortname3, language, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, featured, xreference, publish_up, publish_down, version, hits ` +
		`FROM jlabo.wsub_contact_details ` +
		`WHERE featured = ? AND catid = ?`

	// run query
	XOLog(sqlstr, featured, catid)
	q, err := db.Query(sqlstr, featured, catid)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContactDetail{}
	for q.Next() {
		wcd := WsubContactDetail{
			_exists: true,
		}

		// scan
		err = q.Scan(&wcd.ID, &wcd.Name, &wcd.Alias, &wcd.ConPosition, &wcd.Address, &wcd.Suburb, &wcd.State, &wcd.Country, &wcd.Postcode, &wcd.Telephone, &wcd.Fax, &wcd.Misc, &wcd.Image, &wcd.EmailTo, &wcd.DefaultCon, &wcd.Published, &wcd.CheckedOut, &wcd.CheckedOutTime, &wcd.Ordering, &wcd.Params, &wcd.UserID, &wcd.Catid, &wcd.Access, &wcd.Mobile, &wcd.Webpage, &wcd.Sortname1, &wcd.Sortname2, &wcd.Sortname3, &wcd.Language, &wcd.Created, &wcd.CreatedBy, &wcd.CreatedByAlias, &wcd.Modified, &wcd.ModifiedBy, &wcd.Metakey, &wcd.Metadesc, &wcd.Metadata, &wcd.Featured, &wcd.Xreference, &wcd.PublishUp, &wcd.PublishDown, &wcd.Version, &wcd.Hits)
		if err != nil {
			return nil, err
		}

		res = append(res, &wcd)
	}

	return res, nil
}

// WsubContactDetailsByLanguage retrieves a row from 'jlabo.wsub_contact_details' as a WsubContactDetail.
//
// Generated from index 'idx_language'.
func WsubContactDetailsByLanguage(db XODB, language string) ([]*WsubContactDetail, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, name, alias, con_position, address, suburb, state, country, postcode, telephone, fax, misc, image, email_to, default_con, published, checked_out, checked_out_time, ordering, params, user_id, catid, access, mobile, webpage, sortname1, sortname2, sortname3, language, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, featured, xreference, publish_up, publish_down, version, hits ` +
		`FROM jlabo.wsub_contact_details ` +
		`WHERE language = ?`

	// run query
	XOLog(sqlstr, language)
	q, err := db.Query(sqlstr, language)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContactDetail{}
	for q.Next() {
		wcd := WsubContactDetail{
			_exists: true,
		}

		// scan
		err = q.Scan(&wcd.ID, &wcd.Name, &wcd.Alias, &wcd.ConPosition, &wcd.Address, &wcd.Suburb, &wcd.State, &wcd.Country, &wcd.Postcode, &wcd.Telephone, &wcd.Fax, &wcd.Misc, &wcd.Image, &wcd.EmailTo, &wcd.DefaultCon, &wcd.Published, &wcd.CheckedOut, &wcd.CheckedOutTime, &wcd.Ordering, &wcd.Params, &wcd.UserID, &wcd.Catid, &wcd.Access, &wcd.Mobile, &wcd.Webpage, &wcd.Sortname1, &wcd.Sortname2, &wcd.Sortname3, &wcd.Language, &wcd.Created, &wcd.CreatedBy, &wcd.CreatedByAlias, &wcd.Modified, &wcd.ModifiedBy, &wcd.Metakey, &wcd.Metadesc, &wcd.Metadata, &wcd.Featured, &wcd.Xreference, &wcd.PublishUp, &wcd.PublishDown, &wcd.Version, &wcd.Hits)
		if err != nil {
			return nil, err
		}

		res = append(res, &wcd)
	}

	return res, nil
}

// WsubContactDetailsByPublished retrieves a row from 'jlabo.wsub_contact_details' as a WsubContactDetail.
//
// Generated from index 'idx_state'.
func WsubContactDetailsByPublished(db XODB, published bool) ([]*WsubContactDetail, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, name, alias, con_position, address, suburb, state, country, postcode, telephone, fax, misc, image, email_to, default_con, published, checked_out, checked_out_time, ordering, params, user_id, catid, access, mobile, webpage, sortname1, sortname2, sortname3, language, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, featured, xreference, publish_up, publish_down, version, hits ` +
		`FROM jlabo.wsub_contact_details ` +
		`WHERE published = ?`

	// run query
	XOLog(sqlstr, published)
	q, err := db.Query(sqlstr, published)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContactDetail{}
	for q.Next() {
		wcd := WsubContactDetail{
			_exists: true,
		}

		// scan
		err = q.Scan(&wcd.ID, &wcd.Name, &wcd.Alias, &wcd.ConPosition, &wcd.Address, &wcd.Suburb, &wcd.State, &wcd.Country, &wcd.Postcode, &wcd.Telephone, &wcd.Fax, &wcd.Misc, &wcd.Image, &wcd.EmailTo, &wcd.DefaultCon, &wcd.Published, &wcd.CheckedOut, &wcd.CheckedOutTime, &wcd.Ordering, &wcd.Params, &wcd.UserID, &wcd.Catid, &wcd.Access, &wcd.Mobile, &wcd.Webpage, &wcd.Sortname1, &wcd.Sortname2, &wcd.Sortname3, &wcd.Language, &wcd.Created, &wcd.CreatedBy, &wcd.CreatedByAlias, &wcd.Modified, &wcd.ModifiedBy, &wcd.Metakey, &wcd.Metadesc, &wcd.Metadata, &wcd.Featured, &wcd.Xreference, &wcd.PublishUp, &wcd.PublishDown, &wcd.Version, &wcd.Hits)
		if err != nil {
			return nil, err
		}

		res = append(res, &wcd)
	}

	return res, nil
}

// WsubContactDetailsByXreference retrieves a row from 'jlabo.wsub_contact_details' as a WsubContactDetail.
//
// Generated from index 'idx_xreference'.
func WsubContactDetailsByXreference(db XODB, xreference string) ([]*WsubContactDetail, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, name, alias, con_position, address, suburb, state, country, postcode, telephone, fax, misc, image, email_to, default_con, published, checked_out, checked_out_time, ordering, params, user_id, catid, access, mobile, webpage, sortname1, sortname2, sortname3, language, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, featured, xreference, publish_up, publish_down, version, hits ` +
		`FROM jlabo.wsub_contact_details ` +
		`WHERE xreference = ?`

	// run query
	XOLog(sqlstr, xreference)
	q, err := db.Query(sqlstr, xreference)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubContactDetail{}
	for q.Next() {
		wcd := WsubContactDetail{
			_exists: true,
		}

		// scan
		err = q.Scan(&wcd.ID, &wcd.Name, &wcd.Alias, &wcd.ConPosition, &wcd.Address, &wcd.Suburb, &wcd.State, &wcd.Country, &wcd.Postcode, &wcd.Telephone, &wcd.Fax, &wcd.Misc, &wcd.Image, &wcd.EmailTo, &wcd.DefaultCon, &wcd.Published, &wcd.CheckedOut, &wcd.CheckedOutTime, &wcd.Ordering, &wcd.Params, &wcd.UserID, &wcd.Catid, &wcd.Access, &wcd.Mobile, &wcd.Webpage, &wcd.Sortname1, &wcd.Sortname2, &wcd.Sortname3, &wcd.Language, &wcd.Created, &wcd.CreatedBy, &wcd.CreatedByAlias, &wcd.Modified, &wcd.ModifiedBy, &wcd.Metakey, &wcd.Metadesc, &wcd.Metadata, &wcd.Featured, &wcd.Xreference, &wcd.PublishUp, &wcd.PublishDown, &wcd.Version, &wcd.Hits)
		if err != nil {
			return nil, err
		}

		res = append(res, &wcd)
	}

	return res, nil
}

// WsubContactDetailByID retrieves a row from 'jlabo.wsub_contact_details' as a WsubContactDetail.
//
// Generated from index 'wsub_contact_details_id_pkey'.
func WsubContactDetailByID(db XODB, id int) (*WsubContactDetail, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, name, alias, con_position, address, suburb, state, country, postcode, telephone, fax, misc, image, email_to, default_con, published, checked_out, checked_out_time, ordering, params, user_id, catid, access, mobile, webpage, sortname1, sortname2, sortname3, language, created, created_by, created_by_alias, modified, modified_by, metakey, metadesc, metadata, featured, xreference, publish_up, publish_down, version, hits ` +
		`FROM jlabo.wsub_contact_details ` +
		`WHERE id = ?`

	// run query
	XOLog(sqlstr, id)
	wcd := WsubContactDetail{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&wcd.ID, &wcd.Name, &wcd.Alias, &wcd.ConPosition, &wcd.Address, &wcd.Suburb, &wcd.State, &wcd.Country, &wcd.Postcode, &wcd.Telephone, &wcd.Fax, &wcd.Misc, &wcd.Image, &wcd.EmailTo, &wcd.DefaultCon, &wcd.Published, &wcd.CheckedOut, &wcd.CheckedOutTime, &wcd.Ordering, &wcd.Params, &wcd.UserID, &wcd.Catid, &wcd.Access, &wcd.Mobile, &wcd.Webpage, &wcd.Sortname1, &wcd.Sortname2, &wcd.Sortname3, &wcd.Language, &wcd.Created, &wcd.CreatedBy, &wcd.CreatedByAlias, &wcd.Modified, &wcd.ModifiedBy, &wcd.Metakey, &wcd.Metadesc, &wcd.Metadata, &wcd.Featured, &wcd.Xreference, &wcd.PublishUp, &wcd.PublishDown, &wcd.Version, &wcd.Hits)
	if err != nil {
		return nil, err
	}

	return &wcd, nil
}
