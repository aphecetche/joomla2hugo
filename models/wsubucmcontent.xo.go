// Package toto contains the types for schema 'jlabo'.
package toto

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql"
	"errors"
	"time"
)

// WsubUcmContent represents a row from 'jlabo.wsub_ucm_content'.
type WsubUcmContent struct {
	CoreContentID        uint          `json:"core_content_id"`          // core_content_id
	CoreTypeAlias        string        `json:"core_type_alias"`          // core_type_alias
	CoreTitle            string        `json:"core_title"`               // core_title
	CoreAlias            string        `json:"core_alias"`               // core_alias
	CoreBody             string        `json:"core_body"`                // core_body
	CoreState            bool          `json:"core_state"`               // core_state
	CoreCheckedOutTime   string        `json:"core_checked_out_time"`    // core_checked_out_time
	CoreCheckedOutUserID uint          `json:"core_checked_out_user_id"` // core_checked_out_user_id
	CoreAccess           uint          `json:"core_access"`              // core_access
	CoreParams           string        `json:"core_params"`              // core_params
	CoreFeatured         int8          `json:"core_featured"`            // core_featured
	CoreMetadata         string        `json:"core_metadata"`            // core_metadata
	CoreCreatedUserID    uint          `json:"core_created_user_id"`     // core_created_user_id
	CoreCreatedByAlias   string        `json:"core_created_by_alias"`    // core_created_by_alias
	CoreCreatedTime      time.Time     `json:"core_created_time"`        // core_created_time
	CoreModifiedUserID   uint          `json:"core_modified_user_id"`    // core_modified_user_id
	CoreModifiedTime     time.Time     `json:"core_modified_time"`       // core_modified_time
	CoreLanguage         string        `json:"core_language"`            // core_language
	CorePublishUp        time.Time     `json:"core_publish_up"`          // core_publish_up
	CorePublishDown      time.Time     `json:"core_publish_down"`        // core_publish_down
	CoreContentItemID    sql.NullInt64 `json:"core_content_item_id"`     // core_content_item_id
	AssetID              sql.NullInt64 `json:"asset_id"`                 // asset_id
	CoreImages           string        `json:"core_images"`              // core_images
	CoreUrls             string        `json:"core_urls"`                // core_urls
	CoreHits             uint          `json:"core_hits"`                // core_hits
	CoreVersion          uint          `json:"core_version"`             // core_version
	CoreOrdering         int           `json:"core_ordering"`            // core_ordering
	CoreMetakey          string        `json:"core_metakey"`             // core_metakey
	CoreMetadesc         string        `json:"core_metadesc"`            // core_metadesc
	CoreCatid            uint          `json:"core_catid"`               // core_catid
	CoreXreference       string        `json:"core_xreference"`          // core_xreference
	CoreTypeID           sql.NullInt64 `json:"core_type_id"`             // core_type_id

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the WsubUcmContent exists in the database.
func (wuc *WsubUcmContent) Exists() bool {
	return wuc._exists
}

// Deleted provides information if the WsubUcmContent has been deleted from the database.
func (wuc *WsubUcmContent) Deleted() bool {
	return wuc._deleted
}

// Insert inserts the WsubUcmContent to the database.
func (wuc *WsubUcmContent) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if wuc._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO jlabo.wsub_ucm_content (` +
		`core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, wuc.CoreTypeAlias, wuc.CoreTitle, wuc.CoreAlias, wuc.CoreBody, wuc.CoreState, wuc.CoreCheckedOutTime, wuc.CoreCheckedOutUserID, wuc.CoreAccess, wuc.CoreParams, wuc.CoreFeatured, wuc.CoreMetadata, wuc.CoreCreatedUserID, wuc.CoreCreatedByAlias, wuc.CoreCreatedTime, wuc.CoreModifiedUserID, wuc.CoreModifiedTime, wuc.CoreLanguage, wuc.CorePublishUp, wuc.CorePublishDown, wuc.CoreContentItemID, wuc.AssetID, wuc.CoreImages, wuc.CoreUrls, wuc.CoreHits, wuc.CoreVersion, wuc.CoreOrdering, wuc.CoreMetakey, wuc.CoreMetadesc, wuc.CoreCatid, wuc.CoreXreference, wuc.CoreTypeID)
	res, err := db.Exec(sqlstr, wuc.CoreTypeAlias, wuc.CoreTitle, wuc.CoreAlias, wuc.CoreBody, wuc.CoreState, wuc.CoreCheckedOutTime, wuc.CoreCheckedOutUserID, wuc.CoreAccess, wuc.CoreParams, wuc.CoreFeatured, wuc.CoreMetadata, wuc.CoreCreatedUserID, wuc.CoreCreatedByAlias, wuc.CoreCreatedTime, wuc.CoreModifiedUserID, wuc.CoreModifiedTime, wuc.CoreLanguage, wuc.CorePublishUp, wuc.CorePublishDown, wuc.CoreContentItemID, wuc.AssetID, wuc.CoreImages, wuc.CoreUrls, wuc.CoreHits, wuc.CoreVersion, wuc.CoreOrdering, wuc.CoreMetakey, wuc.CoreMetadesc, wuc.CoreCatid, wuc.CoreXreference, wuc.CoreTypeID)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	wuc.CoreContentID = uint(id)
	wuc._exists = true

	return nil
}

// Update updates the WsubUcmContent in the database.
func (wuc *WsubUcmContent) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wuc._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if wuc._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE jlabo.wsub_ucm_content SET ` +
		`core_type_alias = ?, core_title = ?, core_alias = ?, core_body = ?, core_state = ?, core_checked_out_time = ?, core_checked_out_user_id = ?, core_access = ?, core_params = ?, core_featured = ?, core_metadata = ?, core_created_user_id = ?, core_created_by_alias = ?, core_created_time = ?, core_modified_user_id = ?, core_modified_time = ?, core_language = ?, core_publish_up = ?, core_publish_down = ?, core_content_item_id = ?, asset_id = ?, core_images = ?, core_urls = ?, core_hits = ?, core_version = ?, core_ordering = ?, core_metakey = ?, core_metadesc = ?, core_catid = ?, core_xreference = ?, core_type_id = ?` +
		` WHERE core_content_id = ?`

	// run query
	XOLog(sqlstr, wuc.CoreTypeAlias, wuc.CoreTitle, wuc.CoreAlias, wuc.CoreBody, wuc.CoreState, wuc.CoreCheckedOutTime, wuc.CoreCheckedOutUserID, wuc.CoreAccess, wuc.CoreParams, wuc.CoreFeatured, wuc.CoreMetadata, wuc.CoreCreatedUserID, wuc.CoreCreatedByAlias, wuc.CoreCreatedTime, wuc.CoreModifiedUserID, wuc.CoreModifiedTime, wuc.CoreLanguage, wuc.CorePublishUp, wuc.CorePublishDown, wuc.CoreContentItemID, wuc.AssetID, wuc.CoreImages, wuc.CoreUrls, wuc.CoreHits, wuc.CoreVersion, wuc.CoreOrdering, wuc.CoreMetakey, wuc.CoreMetadesc, wuc.CoreCatid, wuc.CoreXreference, wuc.CoreTypeID, wuc.CoreContentID)
	_, err = db.Exec(sqlstr, wuc.CoreTypeAlias, wuc.CoreTitle, wuc.CoreAlias, wuc.CoreBody, wuc.CoreState, wuc.CoreCheckedOutTime, wuc.CoreCheckedOutUserID, wuc.CoreAccess, wuc.CoreParams, wuc.CoreFeatured, wuc.CoreMetadata, wuc.CoreCreatedUserID, wuc.CoreCreatedByAlias, wuc.CoreCreatedTime, wuc.CoreModifiedUserID, wuc.CoreModifiedTime, wuc.CoreLanguage, wuc.CorePublishUp, wuc.CorePublishDown, wuc.CoreContentItemID, wuc.AssetID, wuc.CoreImages, wuc.CoreUrls, wuc.CoreHits, wuc.CoreVersion, wuc.CoreOrdering, wuc.CoreMetakey, wuc.CoreMetadesc, wuc.CoreCatid, wuc.CoreXreference, wuc.CoreTypeID, wuc.CoreContentID)
	return err
}

// Save saves the WsubUcmContent to the database.
func (wuc *WsubUcmContent) Save(db XODB) error {
	if wuc.Exists() {
		return wuc.Update(db)
	}

	return wuc.Insert(db)
}

// Delete deletes the WsubUcmContent from the database.
func (wuc *WsubUcmContent) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wuc._exists {
		return nil
	}

	// if deleted, bail
	if wuc._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM jlabo.wsub_ucm_content WHERE core_content_id = ?`

	// run query
	XOLog(sqlstr, wuc.CoreContentID)
	_, err = db.Exec(sqlstr, wuc.CoreContentID)
	if err != nil {
		return err
	}

	// set deleted
	wuc._deleted = true

	return nil
}

// WsubUcmContentsByCoreAccess retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'idx_access'.
func WsubUcmContentsByCoreAccess(db XODB, coreAccess uint) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_access = ?`

	// run query
	XOLog(sqlstr, coreAccess)
	q, err := db.Query(sqlstr, coreAccess)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentsByCoreAlias retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'idx_alias'.
func WsubUcmContentsByCoreAlias(db XODB, coreAlias string) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_alias = ?`

	// run query
	XOLog(sqlstr, coreAlias)
	q, err := db.Query(sqlstr, coreAlias)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentsByCoreTypeAlias retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'idx_content_type'.
func WsubUcmContentsByCoreTypeAlias(db XODB, coreTypeAlias string) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_type_alias = ?`

	// run query
	XOLog(sqlstr, coreTypeAlias)
	q, err := db.Query(sqlstr, coreTypeAlias)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentsByCoreCheckedOutUserID retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'idx_core_checked_out_user_id'.
func WsubUcmContentsByCoreCheckedOutUserID(db XODB, coreCheckedOutUserID uint) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_checked_out_user_id = ?`

	// run query
	XOLog(sqlstr, coreCheckedOutUserID)
	q, err := db.Query(sqlstr, coreCheckedOutUserID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentsByCoreCreatedUserID retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'idx_core_created_user_id'.
func WsubUcmContentsByCoreCreatedUserID(db XODB, coreCreatedUserID uint) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_created_user_id = ?`

	// run query
	XOLog(sqlstr, coreCreatedUserID)
	q, err := db.Query(sqlstr, coreCreatedUserID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentsByCoreModifiedUserID retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'idx_core_modified_user_id'.
func WsubUcmContentsByCoreModifiedUserID(db XODB, coreModifiedUserID uint) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_modified_user_id = ?`

	// run query
	XOLog(sqlstr, coreModifiedUserID)
	q, err := db.Query(sqlstr, coreModifiedUserID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentsByCoreTypeID retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'idx_core_type_id'.
func WsubUcmContentsByCoreTypeID(db XODB, coreTypeID sql.NullInt64) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_type_id = ?`

	// run query
	XOLog(sqlstr, coreTypeID)
	q, err := db.Query(sqlstr, coreTypeID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentsByCoreCreatedTime retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'idx_created_time'.
func WsubUcmContentsByCoreCreatedTime(db XODB, coreCreatedTime time.Time) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_created_time = ?`

	// run query
	XOLog(sqlstr, coreCreatedTime)
	q, err := db.Query(sqlstr, coreCreatedTime)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentsByCoreLanguage retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'idx_language'.
func WsubUcmContentsByCoreLanguage(db XODB, coreLanguage string) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_language = ?`

	// run query
	XOLog(sqlstr, coreLanguage)
	q, err := db.Query(sqlstr, coreLanguage)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentsByCoreModifiedTime retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'idx_modified_time'.
func WsubUcmContentsByCoreModifiedTime(db XODB, coreModifiedTime time.Time) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_modified_time = ?`

	// run query
	XOLog(sqlstr, coreModifiedTime)
	q, err := db.Query(sqlstr, coreModifiedTime)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentsByCoreTitle retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'idx_title'.
func WsubUcmContentsByCoreTitle(db XODB, coreTitle string) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_title = ?`

	// run query
	XOLog(sqlstr, coreTitle)
	q, err := db.Query(sqlstr, coreTitle)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentsByCoreStateCoreAccess retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'tag_idx'.
func WsubUcmContentsByCoreStateCoreAccess(db XODB, coreState bool, coreAccess uint) ([]*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_state = ? AND core_access = ?`

	// run query
	XOLog(sqlstr, coreState, coreAccess)
	q, err := db.Query(sqlstr, coreState, coreAccess)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUcmContent{}
	for q.Next() {
		wuc := WsubUcmContent{
			_exists: true,
		}

		// scan
		err = q.Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &wuc)
	}

	return res, nil
}

// WsubUcmContentByCoreContentID retrieves a row from 'jlabo.wsub_ucm_content' as a WsubUcmContent.
//
// Generated from index 'wsub_ucm_content_core_content_id_pkey'.
func WsubUcmContentByCoreContentID(db XODB, coreContentID uint) (*WsubUcmContent, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`core_content_id, core_type_alias, core_title, core_alias, core_body, core_state, core_checked_out_time, core_checked_out_user_id, core_access, core_params, core_featured, core_metadata, core_created_user_id, core_created_by_alias, core_created_time, core_modified_user_id, core_modified_time, core_language, core_publish_up, core_publish_down, core_content_item_id, asset_id, core_images, core_urls, core_hits, core_version, core_ordering, core_metakey, core_metadesc, core_catid, core_xreference, core_type_id ` +
		`FROM jlabo.wsub_ucm_content ` +
		`WHERE core_content_id = ?`

	// run query
	XOLog(sqlstr, coreContentID)
	wuc := WsubUcmContent{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, coreContentID).Scan(&wuc.CoreContentID, &wuc.CoreTypeAlias, &wuc.CoreTitle, &wuc.CoreAlias, &wuc.CoreBody, &wuc.CoreState, &wuc.CoreCheckedOutTime, &wuc.CoreCheckedOutUserID, &wuc.CoreAccess, &wuc.CoreParams, &wuc.CoreFeatured, &wuc.CoreMetadata, &wuc.CoreCreatedUserID, &wuc.CoreCreatedByAlias, &wuc.CoreCreatedTime, &wuc.CoreModifiedUserID, &wuc.CoreModifiedTime, &wuc.CoreLanguage, &wuc.CorePublishUp, &wuc.CorePublishDown, &wuc.CoreContentItemID, &wuc.AssetID, &wuc.CoreImages, &wuc.CoreUrls, &wuc.CoreHits, &wuc.CoreVersion, &wuc.CoreOrdering, &wuc.CoreMetakey, &wuc.CoreMetadesc, &wuc.CoreCatid, &wuc.CoreXreference, &wuc.CoreTypeID)
	if err != nil {
		return nil, err
	}

	return &wuc, nil
}
