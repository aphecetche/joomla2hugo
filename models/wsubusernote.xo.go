// Package toto contains the types for schema 'jlabo'.
package toto

// Code generated by xo. DO NOT EDIT.

import (
	"errors"
	"time"
)

// WsubUserNote represents a row from 'jlabo.wsub_user_notes'.
type WsubUserNote struct {
	ID             uint      `json:"id"`               // id
	UserID         uint      `json:"user_id"`          // user_id
	Catid          uint      `json:"catid"`            // catid
	Subject        string    `json:"subject"`          // subject
	Body           string    `json:"body"`             // body
	State          int8      `json:"state"`            // state
	CheckedOut     uint      `json:"checked_out"`      // checked_out
	CheckedOutTime time.Time `json:"checked_out_time"` // checked_out_time
	CreatedUserID  uint      `json:"created_user_id"`  // created_user_id
	CreatedTime    time.Time `json:"created_time"`     // created_time
	ModifiedUserID uint      `json:"modified_user_id"` // modified_user_id
	ModifiedTime   time.Time `json:"modified_time"`    // modified_time
	ReviewTime     time.Time `json:"review_time"`      // review_time
	PublishUp      time.Time `json:"publish_up"`       // publish_up
	PublishDown    time.Time `json:"publish_down"`     // publish_down

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the WsubUserNote exists in the database.
func (wun *WsubUserNote) Exists() bool {
	return wun._exists
}

// Deleted provides information if the WsubUserNote has been deleted from the database.
func (wun *WsubUserNote) Deleted() bool {
	return wun._deleted
}

// Insert inserts the WsubUserNote to the database.
func (wun *WsubUserNote) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if wun._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO jlabo.wsub_user_notes (` +
		`user_id, catid, subject, body, state, checked_out, checked_out_time, created_user_id, created_time, modified_user_id, modified_time, review_time, publish_up, publish_down` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, wun.UserID, wun.Catid, wun.Subject, wun.Body, wun.State, wun.CheckedOut, wun.CheckedOutTime, wun.CreatedUserID, wun.CreatedTime, wun.ModifiedUserID, wun.ModifiedTime, wun.ReviewTime, wun.PublishUp, wun.PublishDown)
	res, err := db.Exec(sqlstr, wun.UserID, wun.Catid, wun.Subject, wun.Body, wun.State, wun.CheckedOut, wun.CheckedOutTime, wun.CreatedUserID, wun.CreatedTime, wun.ModifiedUserID, wun.ModifiedTime, wun.ReviewTime, wun.PublishUp, wun.PublishDown)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	wun.ID = uint(id)
	wun._exists = true

	return nil
}

// Update updates the WsubUserNote in the database.
func (wun *WsubUserNote) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wun._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if wun._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE jlabo.wsub_user_notes SET ` +
		`user_id = ?, catid = ?, subject = ?, body = ?, state = ?, checked_out = ?, checked_out_time = ?, created_user_id = ?, created_time = ?, modified_user_id = ?, modified_time = ?, review_time = ?, publish_up = ?, publish_down = ?` +
		` WHERE id = ?`

	// run query
	XOLog(sqlstr, wun.UserID, wun.Catid, wun.Subject, wun.Body, wun.State, wun.CheckedOut, wun.CheckedOutTime, wun.CreatedUserID, wun.CreatedTime, wun.ModifiedUserID, wun.ModifiedTime, wun.ReviewTime, wun.PublishUp, wun.PublishDown, wun.ID)
	_, err = db.Exec(sqlstr, wun.UserID, wun.Catid, wun.Subject, wun.Body, wun.State, wun.CheckedOut, wun.CheckedOutTime, wun.CreatedUserID, wun.CreatedTime, wun.ModifiedUserID, wun.ModifiedTime, wun.ReviewTime, wun.PublishUp, wun.PublishDown, wun.ID)
	return err
}

// Save saves the WsubUserNote to the database.
func (wun *WsubUserNote) Save(db XODB) error {
	if wun.Exists() {
		return wun.Update(db)
	}

	return wun.Insert(db)
}

// Delete deletes the WsubUserNote from the database.
func (wun *WsubUserNote) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wun._exists {
		return nil
	}

	// if deleted, bail
	if wun._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM jlabo.wsub_user_notes WHERE id = ?`

	// run query
	XOLog(sqlstr, wun.ID)
	_, err = db.Exec(sqlstr, wun.ID)
	if err != nil {
		return err
	}

	// set deleted
	wun._deleted = true

	return nil
}

// WsubUserNotesByCatid retrieves a row from 'jlabo.wsub_user_notes' as a WsubUserNote.
//
// Generated from index 'idx_category_id'.
func WsubUserNotesByCatid(db XODB, catid uint) ([]*WsubUserNote, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, user_id, catid, subject, body, state, checked_out, checked_out_time, created_user_id, created_time, modified_user_id, modified_time, review_time, publish_up, publish_down ` +
		`FROM jlabo.wsub_user_notes ` +
		`WHERE catid = ?`

	// run query
	XOLog(sqlstr, catid)
	q, err := db.Query(sqlstr, catid)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUserNote{}
	for q.Next() {
		wun := WsubUserNote{
			_exists: true,
		}

		// scan
		err = q.Scan(&wun.ID, &wun.UserID, &wun.Catid, &wun.Subject, &wun.Body, &wun.State, &wun.CheckedOut, &wun.CheckedOutTime, &wun.CreatedUserID, &wun.CreatedTime, &wun.ModifiedUserID, &wun.ModifiedTime, &wun.ReviewTime, &wun.PublishUp, &wun.PublishDown)
		if err != nil {
			return nil, err
		}

		res = append(res, &wun)
	}

	return res, nil
}

// WsubUserNotesByUserID retrieves a row from 'jlabo.wsub_user_notes' as a WsubUserNote.
//
// Generated from index 'idx_user_id'.
func WsubUserNotesByUserID(db XODB, userID uint) ([]*WsubUserNote, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, user_id, catid, subject, body, state, checked_out, checked_out_time, created_user_id, created_time, modified_user_id, modified_time, review_time, publish_up, publish_down ` +
		`FROM jlabo.wsub_user_notes ` +
		`WHERE user_id = ?`

	// run query
	XOLog(sqlstr, userID)
	q, err := db.Query(sqlstr, userID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubUserNote{}
	for q.Next() {
		wun := WsubUserNote{
			_exists: true,
		}

		// scan
		err = q.Scan(&wun.ID, &wun.UserID, &wun.Catid, &wun.Subject, &wun.Body, &wun.State, &wun.CheckedOut, &wun.CheckedOutTime, &wun.CreatedUserID, &wun.CreatedTime, &wun.ModifiedUserID, &wun.ModifiedTime, &wun.ReviewTime, &wun.PublishUp, &wun.PublishDown)
		if err != nil {
			return nil, err
		}

		res = append(res, &wun)
	}

	return res, nil
}

// WsubUserNoteByID retrieves a row from 'jlabo.wsub_user_notes' as a WsubUserNote.
//
// Generated from index 'wsub_user_notes_id_pkey'.
func WsubUserNoteByID(db XODB, id uint) (*WsubUserNote, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, user_id, catid, subject, body, state, checked_out, checked_out_time, created_user_id, created_time, modified_user_id, modified_time, review_time, publish_up, publish_down ` +
		`FROM jlabo.wsub_user_notes ` +
		`WHERE id = ?`

	// run query
	XOLog(sqlstr, id)
	wun := WsubUserNote{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&wun.ID, &wun.UserID, &wun.Catid, &wun.Subject, &wun.Body, &wun.State, &wun.CheckedOut, &wun.CheckedOutTime, &wun.CreatedUserID, &wun.CreatedTime, &wun.ModifiedUserID, &wun.ModifiedTime, &wun.ReviewTime, &wun.PublishUp, &wun.PublishDown)
	if err != nil {
		return nil, err
	}

	return &wun, nil
}
