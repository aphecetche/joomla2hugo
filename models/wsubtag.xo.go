// Package toto contains the types for schema 'jlabo'.
package toto

// Code generated by xo. DO NOT EDIT.

import (
	"errors"
	"time"
)

// WsubTag represents a row from 'jlabo.wsub_tags'.
type WsubTag struct {
	ID             uint      `json:"id"`               // id
	ParentID       uint      `json:"parent_id"`        // parent_id
	Lft            int       `json:"lft"`              // lft
	Rgt            int       `json:"rgt"`              // rgt
	Level          uint      `json:"level"`            // level
	Path           string    `json:"path"`             // path
	Title          string    `json:"title"`            // title
	Alias          string    `json:"alias"`            // alias
	Note           string    `json:"note"`             // note
	Description    string    `json:"description"`      // description
	Published      bool      `json:"published"`        // published
	CheckedOut     uint      `json:"checked_out"`      // checked_out
	CheckedOutTime time.Time `json:"checked_out_time"` // checked_out_time
	Access         uint      `json:"access"`           // access
	Params         string    `json:"params"`           // params
	Metadesc       string    `json:"metadesc"`         // metadesc
	Metakey        string    `json:"metakey"`          // metakey
	Metadata       string    `json:"metadata"`         // metadata
	CreatedUserID  uint      `json:"created_user_id"`  // created_user_id
	CreatedTime    time.Time `json:"created_time"`     // created_time
	CreatedByAlias string    `json:"created_by_alias"` // created_by_alias
	ModifiedUserID uint      `json:"modified_user_id"` // modified_user_id
	ModifiedTime   time.Time `json:"modified_time"`    // modified_time
	Images         string    `json:"images"`           // images
	Urls           string    `json:"urls"`             // urls
	Hits           uint      `json:"hits"`             // hits
	Language       string    `json:"language"`         // language
	Version        uint      `json:"version"`          // version
	PublishUp      time.Time `json:"publish_up"`       // publish_up
	PublishDown    time.Time `json:"publish_down"`     // publish_down

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the WsubTag exists in the database.
func (wt *WsubTag) Exists() bool {
	return wt._exists
}

// Deleted provides information if the WsubTag has been deleted from the database.
func (wt *WsubTag) Deleted() bool {
	return wt._deleted
}

// Insert inserts the WsubTag to the database.
func (wt *WsubTag) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if wt._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO jlabo.wsub_tags (` +
		`parent_id, lft, rgt, level, path, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, created_by_alias, modified_user_id, modified_time, images, urls, hits, language, version, publish_up, publish_down` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, wt.ParentID, wt.Lft, wt.Rgt, wt.Level, wt.Path, wt.Title, wt.Alias, wt.Note, wt.Description, wt.Published, wt.CheckedOut, wt.CheckedOutTime, wt.Access, wt.Params, wt.Metadesc, wt.Metakey, wt.Metadata, wt.CreatedUserID, wt.CreatedTime, wt.CreatedByAlias, wt.ModifiedUserID, wt.ModifiedTime, wt.Images, wt.Urls, wt.Hits, wt.Language, wt.Version, wt.PublishUp, wt.PublishDown)
	res, err := db.Exec(sqlstr, wt.ParentID, wt.Lft, wt.Rgt, wt.Level, wt.Path, wt.Title, wt.Alias, wt.Note, wt.Description, wt.Published, wt.CheckedOut, wt.CheckedOutTime, wt.Access, wt.Params, wt.Metadesc, wt.Metakey, wt.Metadata, wt.CreatedUserID, wt.CreatedTime, wt.CreatedByAlias, wt.ModifiedUserID, wt.ModifiedTime, wt.Images, wt.Urls, wt.Hits, wt.Language, wt.Version, wt.PublishUp, wt.PublishDown)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	wt.ID = uint(id)
	wt._exists = true

	return nil
}

// Update updates the WsubTag in the database.
func (wt *WsubTag) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wt._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if wt._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE jlabo.wsub_tags SET ` +
		`parent_id = ?, lft = ?, rgt = ?, level = ?, path = ?, title = ?, alias = ?, note = ?, description = ?, published = ?, checked_out = ?, checked_out_time = ?, access = ?, params = ?, metadesc = ?, metakey = ?, metadata = ?, created_user_id = ?, created_time = ?, created_by_alias = ?, modified_user_id = ?, modified_time = ?, images = ?, urls = ?, hits = ?, language = ?, version = ?, publish_up = ?, publish_down = ?` +
		` WHERE id = ?`

	// run query
	XOLog(sqlstr, wt.ParentID, wt.Lft, wt.Rgt, wt.Level, wt.Path, wt.Title, wt.Alias, wt.Note, wt.Description, wt.Published, wt.CheckedOut, wt.CheckedOutTime, wt.Access, wt.Params, wt.Metadesc, wt.Metakey, wt.Metadata, wt.CreatedUserID, wt.CreatedTime, wt.CreatedByAlias, wt.ModifiedUserID, wt.ModifiedTime, wt.Images, wt.Urls, wt.Hits, wt.Language, wt.Version, wt.PublishUp, wt.PublishDown, wt.ID)
	_, err = db.Exec(sqlstr, wt.ParentID, wt.Lft, wt.Rgt, wt.Level, wt.Path, wt.Title, wt.Alias, wt.Note, wt.Description, wt.Published, wt.CheckedOut, wt.CheckedOutTime, wt.Access, wt.Params, wt.Metadesc, wt.Metakey, wt.Metadata, wt.CreatedUserID, wt.CreatedTime, wt.CreatedByAlias, wt.ModifiedUserID, wt.ModifiedTime, wt.Images, wt.Urls, wt.Hits, wt.Language, wt.Version, wt.PublishUp, wt.PublishDown, wt.ID)
	return err
}

// Save saves the WsubTag to the database.
func (wt *WsubTag) Save(db XODB) error {
	if wt.Exists() {
		return wt.Update(db)
	}

	return wt.Insert(db)
}

// Delete deletes the WsubTag from the database.
func (wt *WsubTag) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !wt._exists {
		return nil
	}

	// if deleted, bail
	if wt._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM jlabo.wsub_tags WHERE id = ?`

	// run query
	XOLog(sqlstr, wt.ID)
	_, err = db.Exec(sqlstr, wt.ID)
	if err != nil {
		return err
	}

	// set deleted
	wt._deleted = true

	return nil
}

// WsubTagsByAccess retrieves a row from 'jlabo.wsub_tags' as a WsubTag.
//
// Generated from index 'idx_access'.
func WsubTagsByAccess(db XODB, access uint) ([]*WsubTag, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, parent_id, lft, rgt, level, path, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, created_by_alias, modified_user_id, modified_time, images, urls, hits, language, version, publish_up, publish_down ` +
		`FROM jlabo.wsub_tags ` +
		`WHERE access = ?`

	// run query
	XOLog(sqlstr, access)
	q, err := db.Query(sqlstr, access)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubTag{}
	for q.Next() {
		wt := WsubTag{
			_exists: true,
		}

		// scan
		err = q.Scan(&wt.ID, &wt.ParentID, &wt.Lft, &wt.Rgt, &wt.Level, &wt.Path, &wt.Title, &wt.Alias, &wt.Note, &wt.Description, &wt.Published, &wt.CheckedOut, &wt.CheckedOutTime, &wt.Access, &wt.Params, &wt.Metadesc, &wt.Metakey, &wt.Metadata, &wt.CreatedUserID, &wt.CreatedTime, &wt.CreatedByAlias, &wt.ModifiedUserID, &wt.ModifiedTime, &wt.Images, &wt.Urls, &wt.Hits, &wt.Language, &wt.Version, &wt.PublishUp, &wt.PublishDown)
		if err != nil {
			return nil, err
		}

		res = append(res, &wt)
	}

	return res, nil
}

// WsubTagsByAlias retrieves a row from 'jlabo.wsub_tags' as a WsubTag.
//
// Generated from index 'idx_alias'.
func WsubTagsByAlias(db XODB, alias string) ([]*WsubTag, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, parent_id, lft, rgt, level, path, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, created_by_alias, modified_user_id, modified_time, images, urls, hits, language, version, publish_up, publish_down ` +
		`FROM jlabo.wsub_tags ` +
		`WHERE alias = ?`

	// run query
	XOLog(sqlstr, alias)
	q, err := db.Query(sqlstr, alias)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubTag{}
	for q.Next() {
		wt := WsubTag{
			_exists: true,
		}

		// scan
		err = q.Scan(&wt.ID, &wt.ParentID, &wt.Lft, &wt.Rgt, &wt.Level, &wt.Path, &wt.Title, &wt.Alias, &wt.Note, &wt.Description, &wt.Published, &wt.CheckedOut, &wt.CheckedOutTime, &wt.Access, &wt.Params, &wt.Metadesc, &wt.Metakey, &wt.Metadata, &wt.CreatedUserID, &wt.CreatedTime, &wt.CreatedByAlias, &wt.ModifiedUserID, &wt.ModifiedTime, &wt.Images, &wt.Urls, &wt.Hits, &wt.Language, &wt.Version, &wt.PublishUp, &wt.PublishDown)
		if err != nil {
			return nil, err
		}

		res = append(res, &wt)
	}

	return res, nil
}

// WsubTagsByCheckedOut retrieves a row from 'jlabo.wsub_tags' as a WsubTag.
//
// Generated from index 'idx_checkout'.
func WsubTagsByCheckedOut(db XODB, checkedOut uint) ([]*WsubTag, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, parent_id, lft, rgt, level, path, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, created_by_alias, modified_user_id, modified_time, images, urls, hits, language, version, publish_up, publish_down ` +
		`FROM jlabo.wsub_tags ` +
		`WHERE checked_out = ?`

	// run query
	XOLog(sqlstr, checkedOut)
	q, err := db.Query(sqlstr, checkedOut)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubTag{}
	for q.Next() {
		wt := WsubTag{
			_exists: true,
		}

		// scan
		err = q.Scan(&wt.ID, &wt.ParentID, &wt.Lft, &wt.Rgt, &wt.Level, &wt.Path, &wt.Title, &wt.Alias, &wt.Note, &wt.Description, &wt.Published, &wt.CheckedOut, &wt.CheckedOutTime, &wt.Access, &wt.Params, &wt.Metadesc, &wt.Metakey, &wt.Metadata, &wt.CreatedUserID, &wt.CreatedTime, &wt.CreatedByAlias, &wt.ModifiedUserID, &wt.ModifiedTime, &wt.Images, &wt.Urls, &wt.Hits, &wt.Language, &wt.Version, &wt.PublishUp, &wt.PublishDown)
		if err != nil {
			return nil, err
		}

		res = append(res, &wt)
	}

	return res, nil
}

// WsubTagsByLanguage retrieves a row from 'jlabo.wsub_tags' as a WsubTag.
//
// Generated from index 'idx_language'.
func WsubTagsByLanguage(db XODB, language string) ([]*WsubTag, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, parent_id, lft, rgt, level, path, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, created_by_alias, modified_user_id, modified_time, images, urls, hits, language, version, publish_up, publish_down ` +
		`FROM jlabo.wsub_tags ` +
		`WHERE language = ?`

	// run query
	XOLog(sqlstr, language)
	q, err := db.Query(sqlstr, language)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubTag{}
	for q.Next() {
		wt := WsubTag{
			_exists: true,
		}

		// scan
		err = q.Scan(&wt.ID, &wt.ParentID, &wt.Lft, &wt.Rgt, &wt.Level, &wt.Path, &wt.Title, &wt.Alias, &wt.Note, &wt.Description, &wt.Published, &wt.CheckedOut, &wt.CheckedOutTime, &wt.Access, &wt.Params, &wt.Metadesc, &wt.Metakey, &wt.Metadata, &wt.CreatedUserID, &wt.CreatedTime, &wt.CreatedByAlias, &wt.ModifiedUserID, &wt.ModifiedTime, &wt.Images, &wt.Urls, &wt.Hits, &wt.Language, &wt.Version, &wt.PublishUp, &wt.PublishDown)
		if err != nil {
			return nil, err
		}

		res = append(res, &wt)
	}

	return res, nil
}

// WsubTagsByLftRgt retrieves a row from 'jlabo.wsub_tags' as a WsubTag.
//
// Generated from index 'idx_left_right'.
func WsubTagsByLftRgt(db XODB, lft int, rgt int) ([]*WsubTag, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, parent_id, lft, rgt, level, path, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, created_by_alias, modified_user_id, modified_time, images, urls, hits, language, version, publish_up, publish_down ` +
		`FROM jlabo.wsub_tags ` +
		`WHERE lft = ? AND rgt = ?`

	// run query
	XOLog(sqlstr, lft, rgt)
	q, err := db.Query(sqlstr, lft, rgt)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubTag{}
	for q.Next() {
		wt := WsubTag{
			_exists: true,
		}

		// scan
		err = q.Scan(&wt.ID, &wt.ParentID, &wt.Lft, &wt.Rgt, &wt.Level, &wt.Path, &wt.Title, &wt.Alias, &wt.Note, &wt.Description, &wt.Published, &wt.CheckedOut, &wt.CheckedOutTime, &wt.Access, &wt.Params, &wt.Metadesc, &wt.Metakey, &wt.Metadata, &wt.CreatedUserID, &wt.CreatedTime, &wt.CreatedByAlias, &wt.ModifiedUserID, &wt.ModifiedTime, &wt.Images, &wt.Urls, &wt.Hits, &wt.Language, &wt.Version, &wt.PublishUp, &wt.PublishDown)
		if err != nil {
			return nil, err
		}

		res = append(res, &wt)
	}

	return res, nil
}

// WsubTagsByPath retrieves a row from 'jlabo.wsub_tags' as a WsubTag.
//
// Generated from index 'idx_path'.
func WsubTagsByPath(db XODB, path string) ([]*WsubTag, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, parent_id, lft, rgt, level, path, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, created_by_alias, modified_user_id, modified_time, images, urls, hits, language, version, publish_up, publish_down ` +
		`FROM jlabo.wsub_tags ` +
		`WHERE path = ?`

	// run query
	XOLog(sqlstr, path)
	q, err := db.Query(sqlstr, path)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubTag{}
	for q.Next() {
		wt := WsubTag{
			_exists: true,
		}

		// scan
		err = q.Scan(&wt.ID, &wt.ParentID, &wt.Lft, &wt.Rgt, &wt.Level, &wt.Path, &wt.Title, &wt.Alias, &wt.Note, &wt.Description, &wt.Published, &wt.CheckedOut, &wt.CheckedOutTime, &wt.Access, &wt.Params, &wt.Metadesc, &wt.Metakey, &wt.Metadata, &wt.CreatedUserID, &wt.CreatedTime, &wt.CreatedByAlias, &wt.ModifiedUserID, &wt.ModifiedTime, &wt.Images, &wt.Urls, &wt.Hits, &wt.Language, &wt.Version, &wt.PublishUp, &wt.PublishDown)
		if err != nil {
			return nil, err
		}

		res = append(res, &wt)
	}

	return res, nil
}

// WsubTagsByPublishedAccess retrieves a row from 'jlabo.wsub_tags' as a WsubTag.
//
// Generated from index 'tag_idx'.
func WsubTagsByPublishedAccess(db XODB, published bool, access uint) ([]*WsubTag, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, parent_id, lft, rgt, level, path, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, created_by_alias, modified_user_id, modified_time, images, urls, hits, language, version, publish_up, publish_down ` +
		`FROM jlabo.wsub_tags ` +
		`WHERE published = ? AND access = ?`

	// run query
	XOLog(sqlstr, published, access)
	q, err := db.Query(sqlstr, published, access)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*WsubTag{}
	for q.Next() {
		wt := WsubTag{
			_exists: true,
		}

		// scan
		err = q.Scan(&wt.ID, &wt.ParentID, &wt.Lft, &wt.Rgt, &wt.Level, &wt.Path, &wt.Title, &wt.Alias, &wt.Note, &wt.Description, &wt.Published, &wt.CheckedOut, &wt.CheckedOutTime, &wt.Access, &wt.Params, &wt.Metadesc, &wt.Metakey, &wt.Metadata, &wt.CreatedUserID, &wt.CreatedTime, &wt.CreatedByAlias, &wt.ModifiedUserID, &wt.ModifiedTime, &wt.Images, &wt.Urls, &wt.Hits, &wt.Language, &wt.Version, &wt.PublishUp, &wt.PublishDown)
		if err != nil {
			return nil, err
		}

		res = append(res, &wt)
	}

	return res, nil
}

// WsubTagByID retrieves a row from 'jlabo.wsub_tags' as a WsubTag.
//
// Generated from index 'wsub_tags_id_pkey'.
func WsubTagByID(db XODB, id uint) (*WsubTag, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, parent_id, lft, rgt, level, path, title, alias, note, description, published, checked_out, checked_out_time, access, params, metadesc, metakey, metadata, created_user_id, created_time, created_by_alias, modified_user_id, modified_time, images, urls, hits, language, version, publish_up, publish_down ` +
		`FROM jlabo.wsub_tags ` +
		`WHERE id = ?`

	// run query
	XOLog(sqlstr, id)
	wt := WsubTag{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&wt.ID, &wt.ParentID, &wt.Lft, &wt.Rgt, &wt.Level, &wt.Path, &wt.Title, &wt.Alias, &wt.Note, &wt.Description, &wt.Published, &wt.CheckedOut, &wt.CheckedOutTime, &wt.Access, &wt.Params, &wt.Metadesc, &wt.Metakey, &wt.Metadata, &wt.CreatedUserID, &wt.CreatedTime, &wt.CreatedByAlias, &wt.ModifiedUserID, &wt.ModifiedTime, &wt.Images, &wt.Urls, &wt.Hits, &wt.Language, &wt.Version, &wt.PublishUp, &wt.PublishDown)
	if err != nil {
		return nil, err
	}

	return &wt, nil
}
